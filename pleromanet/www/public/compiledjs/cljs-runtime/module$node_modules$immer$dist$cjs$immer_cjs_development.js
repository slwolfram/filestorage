shadow$provide.module$node_modules$immer$dist$cjs$immer_cjs_development=function(global,require,module,exports){function die(error,...args){error=errors[error];args="function"===typeof error?error.apply(null,args):error;throw Error(`[Immer] ${args}`);throw Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);}function isDraft(value){return!!value&&!!value[DRAFT_STATE]}function isDraftable(value){return value?isPlainObject(value)||Array.isArray(value)||!!value[DRAFTABLE]||
!!value.constructor?.[DRAFTABLE]||isMap(value)||isSet(value):!1}function isPlainObject(value){if(!value||"object"!==typeof value)return!1;value=getPrototypeOf(value);if(null===value)return!0;value=Object.hasOwnProperty.call(value,"constructor")&&value.constructor;return value===Object?!0:"function"==typeof value&&Function.toString.call(value)===objectCtorString}function original(value){isDraft(value)||die(15,value);return value[DRAFT_STATE].base_}function each(obj,iter){0===getArchtype(obj)?Object.entries(obj).forEach(([key,
value])=>{iter(key,value,obj)}):obj.forEach((entry,index)=>iter(index,entry,obj))}function getArchtype(thing){const state=thing[DRAFT_STATE];return state?state.type_:Array.isArray(thing)?1:isMap(thing)?2:isSet(thing)?3:0}function has(thing,prop){return 2===getArchtype(thing)?thing.has(prop):Object.prototype.hasOwnProperty.call(thing,prop)}function get(thing,prop){return 2===getArchtype(thing)?thing.get(prop):thing[prop]}function set(thing,propOrOldValue,value){const t=getArchtype(thing);2===t?thing.set(propOrOldValue,
value):3===t?thing.add(value):thing[propOrOldValue]=value}function isMap(target){return target instanceof Map}function isSet(target){return target instanceof Set}function latest(state){return state.copy_||state.base_}function shallowCopy(base,strict){if(isMap(base))return new Map(base);if(isSet(base))return new Set(base);if(Array.isArray(base))return Array.prototype.slice.call(base);if(!strict&&isPlainObject(base))return getPrototypeOf(base)?{...base}:(strict=Object.create(null),Object.assign(strict,
base));strict=Object.getOwnPropertyDescriptors(base);delete strict[DRAFT_STATE];let keys=Reflect.ownKeys(strict);for(let i=0;i<keys.length;i++){const key=keys[i],desc=strict[key];!1===desc.writable&&(desc.writable=!0,desc.configurable=!0);if(desc.get||desc.set)strict[key]={configurable:!0,writable:!0,enumerable:desc.enumerable,value:base[key]}}return Object.create(getPrototypeOf(base),strict)}function freeze(obj,deep=!1){if(Object.isFrozen(obj)||isDraft(obj)||!isDraftable(obj))return obj;1<getArchtype(obj)&&
(obj.set=obj.add=obj.clear=obj.delete=dontMutateFrozenCollections);Object.freeze(obj);deep&&each(obj,(_key,value)=>freeze(value,!0),!0);return obj}function dontMutateFrozenCollections(){die(2)}function getPlugin(pluginKey){const plugin=plugins[pluginKey];plugin||die(0,pluginKey);return plugin}function loadPlugin(pluginKey,implementation){plugins[pluginKey]||(plugins[pluginKey]=implementation)}function createScope(parent_,immer_){return{drafts_:[],parent_,immer_,canAutoFreeze_:!0,unfinalizedDrafts_:0}}
function usePatchesInScope(scope,patchListener){patchListener&&(getPlugin("Patches"),scope.patches_=[],scope.inversePatches_=[],scope.patchListener_=patchListener)}function revokeScope(scope){leaveScope(scope);scope.drafts_.forEach(revokeDraft);scope.drafts_=null}function leaveScope(scope){scope===currentScope&&(currentScope=scope.parent_)}function revokeDraft(draft){draft=draft[DRAFT_STATE];0===draft.type_||1===draft.type_?draft.revoke_():draft.revoked_=!0}function processResult(result,scope){scope.unfinalizedDrafts_=
scope.drafts_.length;const baseDraft=scope.drafts_[0];void 0!==result&&result!==baseDraft?(baseDraft[DRAFT_STATE].modified_&&(revokeScope(scope),die(4)),isDraftable(result)&&(result=finalize(scope,result),scope.parent_||maybeFreeze(scope,result)),scope.patches_&&getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_,result,scope.patches_,scope.inversePatches_)):result=finalize(scope,baseDraft,[]);revokeScope(scope);scope.patches_&&scope.patchListener_(scope.patches_,scope.inversePatches_);
return result!==NOTHING?result:void 0}function finalize(rootScope,value,path){if(Object.isFrozen(value))return value;const state=value[DRAFT_STATE];if(!state)return each(value,(key,childValue)=>finalizeProperty(rootScope,state,value,key,childValue,path),!0),value;if(state.scope_!==rootScope)return value;if(!state.modified_)return maybeFreeze(rootScope,state.base_,!0),state.base_;if(!state.finalized_){state.finalized_=!0;state.scope_.unfinalizedDrafts_--;const result=state.copy_;let resultEach=result,
isSet2=!1;3===state.type_&&(resultEach=new Set(result),result.clear(),isSet2=!0);each(resultEach,(key,childValue)=>finalizeProperty(rootScope,state,result,key,childValue,path,isSet2));maybeFreeze(rootScope,result,!1);path&&rootScope.patches_&&getPlugin("Patches").generatePatches_(state,path,rootScope.patches_,rootScope.inversePatches_)}return state.copy_}function finalizeProperty(rootScope,parentState,targetObject,prop,childValue,rootPath,targetIsSet){childValue===targetObject&&die(5);if(isDraft(childValue))if(rootPath=
rootPath&&parentState&&3!==parentState.type_&&!has(parentState.assigned_,prop)?rootPath.concat(prop):void 0,rootPath=finalize(rootScope,childValue,rootPath),set(targetObject,prop,rootPath),isDraft(rootPath))rootScope.canAutoFreeze_=!1;else return;else targetIsSet&&targetObject.add(childValue);!isDraftable(childValue)||Object.isFrozen(childValue)||!rootScope.immer_.autoFreeze_&&1>rootScope.unfinalizedDrafts_||(finalize(rootScope,childValue),parentState&&parentState.scope_.parent_||maybeFreeze(rootScope,
childValue))}function maybeFreeze(scope,value,deep=!1){!scope.parent_&&scope.immer_.autoFreeze_&&scope.canAutoFreeze_&&freeze(value,deep)}function peek(draft,prop){const state=draft[DRAFT_STATE];return(state?latest(state):draft)[prop]}function getDescriptorFromProto(source,prop){if(prop in source)for(source=getPrototypeOf(source);source;){const desc=Object.getOwnPropertyDescriptor(source,prop);if(desc)return desc;source=getPrototypeOf(source)}}function markChanged(state){state.modified_||(state.modified_=
!0,state.parent_&&markChanged(state.parent_))}function prepareCopy(state){state.copy_||(state.copy_=shallowCopy(state.base_,state.scope_.immer_.useStrictShallowCopy_))}function createProxy(value,parent){if(isMap(value))var JSCompiler_temp=getPlugin("MapSet").proxyMap_(value,parent);else if(isSet(value))JSCompiler_temp=getPlugin("MapSet").proxySet_(value,parent);else{JSCompiler_temp=Array.isArray(value);let target=value={type_:JSCompiler_temp?1:0,scope_:parent?parent.scope_:currentScope,modified_:!1,
finalized_:!1,assigned_:{},parent_:parent,base_:value,draft_:null,copy_:null,revoke_:null,isManual_:!1},traps=objectTraps;JSCompiler_temp&&(target=[value],traps=arrayTraps);const {revoke,proxy}=Proxy.revocable(target,traps);value.draft_=proxy;value.revoke_=revoke;JSCompiler_temp=proxy}(parent?parent.scope_:currentScope).drafts_.push(JSCompiler_temp);return JSCompiler_temp}function current(value){isDraft(value)||die(10,value);return currentImpl(value)}function currentImpl(value){if(!isDraftable(value)||
Object.isFrozen(value))return value;const state=value[DRAFT_STATE];let copy;if(state){if(!state.modified_)return state.base_;state.finalized_=!0;copy=shallowCopy(value,state.scope_.immer_.useStrictShallowCopy_)}else copy=shallowCopy(value,!0);each(copy,(key,childValue)=>{set(copy,key,currentImpl(childValue))});state&&(state.finalized_=!1);return copy}function enablePatches(){function generatePatchesFromAssigned(state,basePath,patches,inversePatches){const {base_,copy_}=state;each(state.assigned_,
(key,assignedValue)=>{const origValue=get(base_,key),value=get(copy_,key);assignedValue=assignedValue?has(base_,key)?"replace":"add":"remove";if(origValue!==value||"replace"!==assignedValue)key=basePath.concat(key),patches.push("remove"===assignedValue?{op:assignedValue,path:key}:{op:assignedValue,path:key,value}),inversePatches.push("add"===assignedValue?{op:"remove",path:key}:"remove"===assignedValue?{op:"add",path:key,value:clonePatchValueIfNeeded(origValue)}:{op:"replace",path:key,value:clonePatchValueIfNeeded(origValue)})})}
function generateSetPatches(state,basePath,patches,inversePatches){let {base_,copy_}=state,i=0;base_.forEach(value=>{if(!copy_.has(value)){const path=basePath.concat([i]);patches.push({op:"remove",path,value});inversePatches.unshift({op:"add",path,value})}i++});i=0;copy_.forEach(value=>{if(!base_.has(value)){const path=basePath.concat([i]);patches.push({op:"add",path,value});inversePatches.unshift({op:"remove",path,value})}i++})}function deepClonePatchValue(obj){if(!isDraftable(obj))return obj;if(Array.isArray(obj))return obj.map(deepClonePatchValue);
if(isMap(obj))return new Map(Array.from(obj.entries()).map(([k,v])=>[k,deepClonePatchValue(v)]));if(isSet(obj))return new Set(Array.from(obj).map(deepClonePatchValue));const cloned=Object.create(getPrototypeOf(obj));for(const key in obj)cloned[key]=deepClonePatchValue(obj[key]);has(obj,DRAFTABLE)&&(cloned[DRAFTABLE]=obj[DRAFTABLE]);return cloned}function clonePatchValueIfNeeded(obj){return isDraft(obj)?deepClonePatchValue(obj):obj}errors.push('Sets cannot have "replace" patches.',function(op){return"Unsupported patch operation: "+
op},function(path){return"Cannot apply patch, path doesn't resolve: "+path},"Patching reserved attributes like __proto__, prototype and constructor is not allowed");loadPlugin("Patches",{applyPatches_:function(draft,patches){patches.forEach(patch=>{const {path,op}=patch;let base=draft;for(var i=0;i<path.length-1;i++){var parentType=getArchtype(base),p=path[i];"string"!==typeof p&&"number"!==typeof p&&(p=""+p);0!==parentType&&1!==parentType||"__proto__"!==p&&"constructor"!==p||die(19);"function"===
typeof base&&"prototype"===p&&die(19);base=get(base,p);"object"!==typeof base&&die(18,path.join("/"))}i=getArchtype(base);parentType=deepClonePatchValue(patch.value);p=path[path.length-1];switch(op){case "replace":switch(i){case 2:return base.set(p,parentType);case 3:die(16);default:return base[p]=parentType}case "add":switch(i){case 1:return"-"===p?base.push(parentType):base.splice(p,0,parentType);case 2:return base.set(p,parentType);case 3:return base.add(parentType);default:return base[p]=parentType}case "remove":switch(i){case 1:return base.splice(p,
1);case 2:return base.delete(p);case 3:return base.delete(patch.value);default:return delete base[p]}default:die(17,op)}});return draft},generatePatches_:function(state,basePath,patches,inversePatches){switch(state.type_){case 0:case 2:return generatePatchesFromAssigned(state,basePath,patches,inversePatches);case 1:let {base_,assigned_}=state;state=state.copy_;state.length<base_.length&&([base_,state]=[state,base_],[patches,inversePatches]=[inversePatches,patches]);for(var i=0;i<base_.length;i++)if(assigned_[i]&&
state[i]!==base_[i]){var path=basePath.concat([i]);patches.push({op:"replace",path,value:clonePatchValueIfNeeded(state[i])});inversePatches.push({op:"replace",path,value:clonePatchValueIfNeeded(base_[i])})}for(i=base_.length;i<state.length;i++)path=basePath.concat([i]),patches.push({op:"add",path,value:clonePatchValueIfNeeded(state[i])});for(patches=state.length-1;base_.length<=patches;--patches)state=basePath.concat([patches]),inversePatches.push({op:"remove",path:state});break;case 3:return generateSetPatches(state,
basePath,patches,inversePatches)}},generateReplacementPatches_:function(baseValue,replacement,patches,inversePatches){patches.push({op:"replace",path:[],value:replacement===NOTHING?void 0:replacement});inversePatches.push({op:"replace",path:[],value:baseValue})}})}function enableMapSet(){function prepareMapCopy(state){state.copy_||(state.assigned_=new Map,state.copy_=new Map(state.base_))}function prepareSetCopy(state){state.copy_||(state.copy_=new Set,state.base_.forEach(value=>{if(isDraftable(value)){const draft=
createProxy(value,state);state.drafts_.set(value,draft);state.copy_.add(draft)}else state.copy_.add(value)}))}function assertUnrevoked(state){state.revoked_&&die(3,JSON.stringify(latest(state)))}class DraftMap extends Map{constructor(target,parent){super();this[DRAFT_STATE]={type_:2,parent_:parent,scope_:parent?parent.scope_:currentScope,modified_:!1,finalized_:!1,copy_:void 0,assigned_:void 0,base_:target,draft_:this,isManual_:!1,revoked_:!1}}get size(){return latest(this[DRAFT_STATE]).size}has(key){return latest(this[DRAFT_STATE]).has(key)}set(key,
value){const state=this[DRAFT_STATE];assertUnrevoked(state);latest(state).has(key)&&latest(state).get(key)===value||(prepareMapCopy(state),markChanged(state),state.assigned_.set(key,!0),state.copy_.set(key,value),state.assigned_.set(key,!0));return this}delete(key){if(!this.has(key))return!1;const state=this[DRAFT_STATE];assertUnrevoked(state);prepareMapCopy(state);markChanged(state);state.base_.has(key)?state.assigned_.set(key,!1):state.assigned_.delete(key);state.copy_.delete(key);return!0}clear(){const state=
this[DRAFT_STATE];assertUnrevoked(state);latest(state).size&&(prepareMapCopy(state),markChanged(state),state.assigned_=new Map,each(state.base_,key=>{state.assigned_.set(key,!1)}),state.copy_.clear())}forEach(cb,thisArg){latest(this[DRAFT_STATE]).forEach((_value,key,_map)=>{cb.call(thisArg,this.get(key),key,this)})}get(key){const state=this[DRAFT_STATE];assertUnrevoked(state);var value=latest(state).get(key);if(state.finalized_||!isDraftable(value)||value!==state.base_.get(key))return value;value=
createProxy(value,state);prepareMapCopy(state);state.copy_.set(key,value);return value}keys(){return latest(this[DRAFT_STATE]).keys()}values(){const iterator=this.keys();return{[Symbol.iterator]:()=>this.values(),next:()=>{const r=iterator.next();return r.done?r:{done:!1,value:this.get(r.value)}}}}entries(){const iterator=this.keys();return{[Symbol.iterator]:()=>this.entries(),next:()=>{const r=iterator.next();if(r.done)return r;const value=this.get(r.value);return{done:!1,value:[r.value,value]}}}}[(DRAFT_STATE,
Symbol.iterator)](){return this.entries()}}class DraftSet extends Set{constructor(target,parent){super();this[DRAFT_STATE]={type_:3,parent_:parent,scope_:parent?parent.scope_:currentScope,modified_:!1,finalized_:!1,copy_:void 0,base_:target,draft_:this,drafts_:new Map,revoked_:!1,isManual_:!1}}get size(){return latest(this[DRAFT_STATE]).size}has(value){const state=this[DRAFT_STATE];assertUnrevoked(state);return state.copy_?state.copy_.has(value)||state.drafts_.has(value)&&state.copy_.has(state.drafts_.get(value))?
!0:!1:state.base_.has(value)}add(value){const state=this[DRAFT_STATE];assertUnrevoked(state);this.has(value)||(prepareSetCopy(state),markChanged(state),state.copy_.add(value));return this}delete(value){if(!this.has(value))return!1;const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);markChanged(state);return state.copy_.delete(value)||(state.drafts_.has(value)?state.copy_.delete(state.drafts_.get(value)):!1)}clear(){const state=this[DRAFT_STATE];assertUnrevoked(state);latest(state).size&&
(prepareSetCopy(state),markChanged(state),state.copy_.clear())}values(){const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);return state.copy_.values()}entries(){const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);return state.copy_.entries()}keys(){return this.values()}[(DRAFT_STATE,Symbol.iterator)](){return this.values()}forEach(cb,thisArg){const iterator=this.values();let result=iterator.next();for(;!result.done;)cb.call(thisArg,result.value,result.value,
this),result=iterator.next()}}loadPlugin("MapSet",{proxyMap_:function(target,parent){return new DraftMap(target,parent)},proxySet_:function(target,parent){return new DraftSet(target,parent)}})}function castDraft(value){return value}function castImmutable(value){return value}var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(to,from,except,desc)=>{if(from&&"object"===
typeof from||"function"===typeof from)for(let key of __getOwnPropNames(from))__hasOwnProp.call(to,key)||key===except||__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to};global={};((target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})})(global,{Immer:()=>Immer2,applyPatches:()=>applyPatches,castDraft:()=>castDraft,castImmutable:()=>castImmutable,createDraft:()=>createDraft,current:()=>current,enableMapSet:()=>
enableMapSet,enablePatches:()=>enablePatches,finishDraft:()=>finishDraft,freeze:()=>freeze,immerable:()=>DRAFTABLE,isDraft:()=>isDraft,isDraftable:()=>isDraftable,nothing:()=>NOTHING,original:()=>original,produce:()=>produce,produceWithPatches:()=>produceWithPatches,setAutoFreeze:()=>setAutoFreeze,setUseStrictShallowCopy:()=>setUseStrictShallowCopy});module.exports=(mod=>__copyProps(__defProp({},"__esModule",{value:!0}),mod))(global);var NOTHING=Symbol.for("immer-nothing"),DRAFTABLE=Symbol.for("immer-draftable"),
DRAFT_STATE=Symbol.for("immer-state"),errors=[function(plugin){return`The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`},function(thing){return`produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`},"This object has been frozen and should not be mutated",function(data){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+
data},"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.","Immer forbids circular references","The first or second argument to `produce` must be a function","The third argument to `produce` must be a function or undefined","First argument to `createDraft` must be a plain object, an array, or an immerable object","First argument to `finishDraft` must be a draft returned by `createDraft`",function(thing){return`'current' expects a draft, got: ${thing}`},
"Object.defineProperty() cannot be used on an Immer draft","Object.setPrototypeOf() cannot be used on an Immer draft","Immer only supports deleting array indices","Immer only supports setting array indices and the 'length' property",function(thing){return`'original' expects a draft, got: ${thing}`}],getPrototypeOf=Object.getPrototypeOf,objectCtorString=Object.prototype.constructor.toString(),plugins={},currentScope,objectTraps={get(state,prop){if(prop===DRAFT_STATE)return state;var source=latest(state);
if(!has(source,prop))return(prop=getDescriptorFromProto(source,prop))?"value"in prop?prop.value:prop.get?.call(state.draft_):void 0;source=source[prop];return state.finalized_||!isDraftable(source)?source:source===peek(state.base_,prop)?(prepareCopy(state),state.copy_[prop]=createProxy(source,state)):source},has(state,prop){return prop in latest(state)},ownKeys(state){return Reflect.ownKeys(latest(state))},set(state,prop,value){var desc=getDescriptorFromProto(latest(state),prop);if(desc?.set)return desc.set.call(state.draft_,
value),!0;if(!state.modified_){desc=peek(latest(state),prop);const currentState=desc?.[DRAFT_STATE];if(currentState&&currentState.base_===value)return state.copy_[prop]=value,state.assigned_[prop]=!1,!0;desc=value===desc?0!==value||1/value===1/desc:value!==value&&desc!==desc;if(desc&&(void 0!==value||has(state.base_,prop)))return!0;prepareCopy(state);markChanged(state)}if(state.copy_[prop]===value&&(void 0!==value||prop in state.copy_)||Number.isNaN(value)&&Number.isNaN(state.copy_[prop]))return!0;
state.copy_[prop]=value;return state.assigned_[prop]=!0},deleteProperty(state,prop){void 0!==peek(state.base_,prop)||prop in state.base_?(state.assigned_[prop]=!1,prepareCopy(state),markChanged(state)):delete state.assigned_[prop];state.copy_&&delete state.copy_[prop];return!0},getOwnPropertyDescriptor(state,prop){const owner=latest(state),desc=Reflect.getOwnPropertyDescriptor(owner,prop);return desc?{writable:!0,configurable:1!==state.type_||"length"!==prop,enumerable:desc.enumerable,value:owner[prop]}:
desc},defineProperty(){die(11)},getPrototypeOf(state){return getPrototypeOf(state.base_)},setPrototypeOf(){die(12)}},arrayTraps={};each(objectTraps,(key,fn)=>{arrayTraps[key]=function(){arguments[0]=arguments[0][0];return fn.apply(this,arguments)}});arrayTraps.deleteProperty=function(state,prop){isNaN(parseInt(prop))&&die(13);return arrayTraps.set.call(this,state,prop,void 0)};arrayTraps.set=function(state,prop,value){"length"!==prop&&isNaN(parseInt(prop))&&die(14);return objectTraps.set.call(this,
state[0],prop,value,state[0])};var Immer2=class{constructor(config){this.autoFreeze_=!0;this.useStrictShallowCopy_=!1;this.produce=(base,recipe,patchListener)=>{if("function"===typeof base&&"function"!==typeof recipe){const defaultBase=recipe;recipe=base;const self=this;return function(base2=defaultBase,...args){return self.produce(base2,draft=>recipe.call(this,draft,...args))}}"function"!==typeof recipe&&die(6);void 0!==patchListener&&"function"!==typeof patchListener&&die(7);let result;if(isDraftable(base)){var scope=
currentScope=createScope(currentScope,this);base=createProxy(base,void 0);var hasError=!0;try{result=recipe(base),hasError=!1}finally{hasError?revokeScope(scope):leaveScope(scope)}usePatchesInScope(scope,patchListener);return processResult(result,scope)}if(base&&"object"===typeof base)die(1,base);else return result=recipe(base),void 0===result&&(result=base),result===NOTHING&&(result=void 0),this.autoFreeze_&&freeze(result,!0),patchListener&&(scope=[],hasError=[],getPlugin("Patches").generateReplacementPatches_(base,
result,scope,hasError),patchListener(scope,hasError)),result};this.produceWithPatches=(base,recipe)=>{if("function"===typeof base)return(state,...args)=>this.produceWithPatches(state,draft=>base(draft,...args));let patches,inversePatches;return[this.produce(base,recipe,(p,ip)=>{patches=p;inversePatches=ip}),patches,inversePatches]};"boolean"===typeof config?.autoFreeze&&this.setAutoFreeze(config.autoFreeze);"boolean"===typeof config?.useStrictShallowCopy&&this.setUseStrictShallowCopy(config.useStrictShallowCopy)}createDraft(base){isDraftable(base)||
die(8);isDraft(base)&&(base=current(base));const scope=currentScope=createScope(currentScope,this);base=createProxy(base,void 0);base[DRAFT_STATE].isManual_=!0;leaveScope(scope);return base}finishDraft(draft,patchListener){(draft=draft&&draft[DRAFT_STATE])&&draft.isManual_||die(9);({scope_:draft}=draft);usePatchesInScope(draft,patchListener);return processResult(void 0,draft)}setAutoFreeze(value){this.autoFreeze_=value}setUseStrictShallowCopy(value){this.useStrictShallowCopy_=value}applyPatches(base,
patches){let i;for(i=patches.length-1;0<=i;i--){const patch=patches[i];if(0===patch.path.length&&"replace"===patch.op){base=patch.value;break}}-1<i&&(patches=patches.slice(i+1));const applyPatchesImpl=getPlugin("Patches").applyPatches_;return isDraft(base)?applyPatchesImpl(base,patches):this.produce(base,draft=>applyPatchesImpl(draft,patches))}};module=new Immer2;var produce=module.produce,produceWithPatches=module.produceWithPatches.bind(module),setAutoFreeze=module.setAutoFreeze.bind(module),setUseStrictShallowCopy=
module.setUseStrictShallowCopy.bind(module),applyPatches=module.applyPatches.bind(module),createDraft=module.createDraft.bind(module),finishDraft=module.finishDraft.bind(module)}
//# sourceMappingURL=module$node_modules$immer$dist$cjs$immer_cjs_development.js.map
