["^ ","~:output",["^ ","~:js","goog.provide('clojure.core.rrb_vector.rrbt');\r\nclojure.core.rrb_vector.rrbt.rrbt_concat_threshold = (33);\r\nclojure.core.rrb_vector.rrbt.max_extra_search_steps = (2);\r\n\r\n/**\r\n * @interface\r\n */\r\nclojure.core.rrb_vector.rrbt.IVecImpl = function(){};\r\n\r\nvar clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$dyn_32922 = (function (v){\r\nvar x__4428__auto__ = (((v == null))?null:v);\r\nvar m__4429__auto__ = (clojure.core.rrb_vector.rrbt._tail_offset[goog.typeOf(x__4428__auto__)]);\r\nif((!((m__4429__auto__ == null)))){\r\nreturn (m__4429__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4429__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__4429__auto__.call(null,v));\r\n} else {\r\nvar m__4426__auto__ = (clojure.core.rrb_vector.rrbt._tail_offset[\"_\"]);\r\nif((!((m__4426__auto__ == null)))){\r\nreturn (m__4426__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4426__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__4426__auto__.call(null,v));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"IVecImpl.-tail-offset\",v);\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt._tail_offset = (function clojure$core$rrb_vector$rrbt$_tail_offset(v){\r\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 == null)))))){\r\nreturn v.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(v);\r\n} else {\r\nreturn clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$dyn_32922(v);\r\n}\r\n});\r\n\r\nvar clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$dyn_32923 = (function (v,i){\r\nvar x__4428__auto__ = (((v == null))?null:v);\r\nvar m__4429__auto__ = (clojure.core.rrb_vector.rrbt._array_for[goog.typeOf(x__4428__auto__)]);\r\nif((!((m__4429__auto__ == null)))){\r\nreturn (m__4429__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4429__auto__.cljs$core$IFn$_invoke$arity$2(v,i) : m__4429__auto__.call(null,v,i));\r\n} else {\r\nvar m__4426__auto__ = (clojure.core.rrb_vector.rrbt._array_for[\"_\"]);\r\nif((!((m__4426__auto__ == null)))){\r\nreturn (m__4426__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4426__auto__.cljs$core$IFn$_invoke$arity$2(v,i) : m__4426__auto__.call(null,v,i));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"IVecImpl.-array-for\",v);\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt._array_for = (function clojure$core$rrb_vector$rrbt$_array_for(v,i){\r\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 == null)))))){\r\nreturn v.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(v,i);\r\n} else {\r\nreturn clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$dyn_32923(v,i);\r\n}\r\n});\r\n\r\n\r\n/**\r\n * @interface\r\n */\r\nclojure.core.rrb_vector.rrbt.AsRRBT = function(){};\r\n\r\nvar clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$dyn_32924 = (function (v){\r\nvar x__4428__auto__ = (((v == null))?null:v);\r\nvar m__4429__auto__ = (clojure.core.rrb_vector.rrbt._as_rrbt[goog.typeOf(x__4428__auto__)]);\r\nif((!((m__4429__auto__ == null)))){\r\nreturn (m__4429__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4429__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__4429__auto__.call(null,v));\r\n} else {\r\nvar m__4426__auto__ = (clojure.core.rrb_vector.rrbt._as_rrbt[\"_\"]);\r\nif((!((m__4426__auto__ == null)))){\r\nreturn (m__4426__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4426__auto__.cljs$core$IFn$_invoke$arity$1(v) : m__4426__auto__.call(null,v));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"AsRRBT.-as-rrbt\",v);\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt._as_rrbt = (function clojure$core$rrb_vector$rrbt$_as_rrbt(v){\r\nif((((!((v == null)))) && ((!((v.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 == null)))))){\r\nreturn v.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1(v);\r\n} else {\r\nreturn clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$dyn_32924(v);\r\n}\r\n});\r\n\r\n\r\n/**\r\n* @constructor\r\n * @implements {cljs.core.IEquiv}\r\n * @implements {cljs.core.IHash}\r\n * @implements {cljs.core.ASeq}\r\n * @implements {cljs.core.ICollection}\r\n * @implements {cljs.core.IChunkedNext}\r\n * @implements {cljs.core.IEmptyableCollection}\r\n * @implements {cljs.core.ISeq}\r\n * @implements {cljs.core.INext}\r\n * @implements {cljs.core.ISeqable}\r\n * @implements {cljs.core.IMeta}\r\n * @implements {cljs.core.IPrintWithWriter}\r\n * @implements {cljs.core.IChunkedSeq}\r\n * @implements {cljs.core.ISequential}\r\n * @implements {cljs.core.IWithMeta}\r\n * @implements {cljs.core.IReduce}\r\n*/\r\nclojure.core.rrb_vector.rrbt.RRBChunkedSeq = (function (vec,node,i,off,meta,__hash){\r\nthis.vec = vec;\r\nthis.node = node;\r\nthis.i = i;\r\nthis.off = off;\r\nthis.meta = meta;\r\nthis.__hash = __hash;\r\nthis.cljs$lang$protocol_mask$partition0$ = 2179858668;\r\nthis.cljs$lang$protocol_mask$partition1$ = 1536;\r\n});\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.toString = (function (){\r\nvar self__ = this;\r\nvar coll = this;\r\nreturn cljs.core.pr_str_STAR_(coll);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this$,writer,opts){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,this$__$1);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn self__.meta;\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nif(((self__.off + (1)) < self__.node.length)){\r\nvar s = (function (){var G__32849 = self__.vec;\r\nvar G__32850 = self__.node;\r\nvar G__32851 = self__.i;\r\nvar G__32852 = (self__.off + (1));\r\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4(G__32849,G__32850,G__32851,G__32852) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null,G__32849,G__32850,G__32851,G__32852));\r\n})();\r\nif((s == null)){\r\nreturn null;\r\n} else {\r\nreturn s;\r\n}\r\n} else {\r\nreturn coll__$1.cljs$core$IChunkedNext$_chunked_next$arity$1(null);\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nvar h__4238__auto__ = self__.__hash;\r\nif((!((h__4238__auto__ == null)))){\r\nreturn h__4238__auto__;\r\n} else {\r\nvar h__4238__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\r\n(self__.__hash = h__4238__auto____$1);\r\n\r\nreturn h__4238__auto____$1;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.equiv_sequential(coll__$1,other);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.with_meta(cljs.core.List.EMPTY,self__.meta);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(self__.vec,(self__.i + self__.off),cljs.core.count(self__.vec)),f);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(self__.vec,(self__.i + self__.off),cljs.core.count(self__.vec)),f,start);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn (self__.node[self__.off]);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nif(((self__.off + (1)) < self__.node.length)){\r\nvar s = (function (){var G__32853 = self__.vec;\r\nvar G__32854 = self__.node;\r\nvar G__32855 = self__.i;\r\nvar G__32856 = (self__.off + (1));\r\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4(G__32853,G__32854,G__32855,G__32856) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null,G__32853,G__32854,G__32855,G__32856));\r\n})();\r\nif((s == null)){\r\nreturn cljs.core.List.EMPTY;\r\n} else {\r\nreturn s;\r\n}\r\n} else {\r\nreturn coll__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null);\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn coll__$1;\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2(self__.node,self__.off);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nvar l = self__.node.length;\r\nvar s = ((((self__.i + l) < cljs.core._count(self__.vec)))?(function (){var G__32857 = self__.vec;\r\nvar G__32858 = (self__.i + l);\r\nvar G__32859 = (0);\r\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(G__32857,G__32858,G__32859) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null,G__32857,G__32858,G__32859));\r\n})():null);\r\nif((s == null)){\r\nreturn cljs.core.List.EMPTY;\r\n} else {\r\nreturn s;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,m){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5(self__.vec,self__.node,self__.i,self__.off,m) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null,self__.vec,self__.node,self__.i,self__.off,m));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nreturn cljs.core.cons(o,coll__$1);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 = (function (coll){\r\nvar self__ = this;\r\nvar coll__$1 = this;\r\nvar l = self__.node.length;\r\nvar s = ((((self__.i + l) < cljs.core._count(self__.vec)))?(function (){var G__32860 = self__.vec;\r\nvar G__32861 = (self__.i + l);\r\nvar G__32862 = (0);\r\nreturn (clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(G__32860,G__32861,G__32862) : clojure.core.rrb_vector.rrbt.rrb_chunked_seq.call(null,G__32860,G__32861,G__32862));\r\n})():null);\r\nif((s == null)){\r\nreturn null;\r\n} else {\r\nreturn s;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.getBasis = (function (){\r\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"vec\",\"vec\",982683596,null),new cljs.core.Symbol(null,\"node\",\"node\",-2073234571,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"off\",\"off\",-2047994980,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$type = true);\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/RRBChunkedSeq\");\r\n\r\n(clojure.core.rrb_vector.rrbt.RRBChunkedSeq.cljs$lang$ctorPrWriter = (function (this__4369__auto__,writer__4370__auto__,opt__4371__auto__){\r\nreturn cljs.core._write(writer__4370__auto__,\"clojure.core.rrb-vector.rrbt/RRBChunkedSeq\");\r\n}));\r\n\r\n/**\r\n * Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq.\r\n */\r\nclojure.core.rrb_vector.rrbt.__GT_RRBChunkedSeq = (function clojure$core$rrb_vector$rrbt$__GT_RRBChunkedSeq(vec,node,i,off,meta,__hash){\r\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,meta,__hash));\r\n});\r\n\r\nclojure.core.rrb_vector.rrbt.rrb_chunked_seq = (function clojure$core$rrb_vector$rrbt$rrb_chunked_seq(var_args){\r\nvar G__32864 = arguments.length;\r\nswitch (G__32864) {\r\ncase 3:\r\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ncase 4:\r\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\r\n\r\nbreak;\r\ncase 5:\r\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3 = (function (vec,i,off){\r\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,clojure.core.rrb_vector.rrbt._array_for(vec,i),i,off,null,null));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$4 = (function (vec,node,i,off){\r\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,null,null));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$5 = (function (vec,node,i,off,meta){\r\nreturn (new clojure.core.rrb_vector.rrbt.RRBChunkedSeq(vec,node,i,off,meta,null));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$lang$maxFixedArity = 5);\r\n\r\nclojure.core.rrb_vector.rrbt.slice_right = (function clojure$core$rrb_vector$rrbt$slice_right(node,shift,end){\r\nif((shift === (0))){\r\nvar arr = node.arr;\r\nvar new_arr = (new Array(end));\r\ncljs.core.array_copy(arr,(0),new_arr,(0),end);\r\n\r\nreturn cljs.core.__GT_VectorNode(null,new_arr);\r\n} else {\r\nvar reg_QMARK_ = clojure.core.rrb_vector.nodes.regular_QMARK_(node);\r\nvar rngs = (((!(reg_QMARK_)))?clojure.core.rrb_vector.nodes.node_ranges(node):null);\r\nvar i = (((end - (1)) >> shift) & (31));\r\nvar i__$1 = ((reg_QMARK_)?i:(function (){var j = i;\r\nwhile(true){\r\nif((end <= (rngs[j]))){\r\nreturn j;\r\n} else {\r\nvar G__32935 = (j + (1));\r\nj = G__32935;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})());\r\nvar child_end = ((reg_QMARK_)?(function (){var ce = cljs.core.mod(end,((1) << shift));\r\nif((ce === (0))){\r\nreturn ((1) << shift);\r\n} else {\r\nreturn ce;\r\n}\r\n})():(((i__$1 > (0)))?(end - (rngs[(i__$1 - (1))])):end));\r\nvar arr = node.arr;\r\nvar new_child = (function (){var G__32865 = (arr[i__$1]);\r\nvar G__32866 = (shift - (5));\r\nvar G__32867 = child_end;\r\nreturn (clojure.core.rrb_vector.rrbt.slice_right.cljs$core$IFn$_invoke$arity$3 ? clojure.core.rrb_vector.rrbt.slice_right.cljs$core$IFn$_invoke$arity$3(G__32865,G__32866,G__32867) : clojure.core.rrb_vector.rrbt.slice_right.call(null,G__32865,G__32866,G__32867));\r\n})();\r\nvar regular_child_QMARK_ = (((shift === (5)))?((32) === new_child.arr.length):clojure.core.rrb_vector.nodes.regular_QMARK_(new_child));\r\nvar new_arr = (new Array(((((reg_QMARK_) && (regular_child_QMARK_)))?(32):(33))));\r\nvar new_child_rng = ((regular_child_QMARK_)?(function (){var m = cljs.core.mod(child_end,((1) << shift));\r\nif((m === (0))){\r\nreturn ((1) << shift);\r\n} else {\r\nreturn m;\r\n}\r\n})():(((shift === (5)))?new_child.arr.length:clojure.core.rrb_vector.nodes.last_range(new_child)));\r\ncljs.core.array_copy(arr,(0),new_arr,(0),i__$1);\r\n\r\n(new_arr[i__$1] = new_child);\r\n\r\nif((!(((reg_QMARK_) && (regular_child_QMARK_))))){\r\nvar new_rngs_32943 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar step_32944 = ((1) << shift);\r\nif(reg_QMARK_){\r\nvar n__4613__auto___32945 = i__$1;\r\nvar j_32946 = (0);\r\nwhile(true){\r\nif((j_32946 < n__4613__auto___32945)){\r\n(new_rngs_32943[j_32946] = ((j_32946 + (1)) * step_32944));\r\n\r\nvar G__32948 = (j_32946 + (1));\r\nj_32946 = G__32948;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar n__4613__auto___32950 = i__$1;\r\nvar j_32951 = (0);\r\nwhile(true){\r\nif((j_32951 < n__4613__auto___32950)){\r\n(new_rngs_32943[j_32951] = (rngs[j_32951]));\r\n\r\nvar G__32952 = (j_32951 + (1));\r\nj_32951 = G__32952;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n}\r\n\r\n(new_rngs_32943[i__$1] = ((((i__$1 > (0)))?(new_rngs_32943[(i__$1 - (1))]):(0)) + new_child_rng));\r\n\r\n(new_rngs_32943[(32)] = (i__$1 + (1)));\r\n\r\n(new_arr[(32)] = new_rngs_32943);\r\n} else {\r\n}\r\n\r\nreturn cljs.core.__GT_VectorNode(null,new_arr);\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.slice_left = (function clojure$core$rrb_vector$rrbt$slice_left(node,shift,start,end){\r\nif((shift === (0))){\r\nvar arr = node.arr;\r\nvar new_len = (arr.length - start);\r\nvar new_arr = (new Array(new_len));\r\ncljs.core.array_copy(arr,start,new_arr,(0),new_len);\r\n\r\nreturn cljs.core.__GT_VectorNode(null,new_arr);\r\n} else {\r\nvar reg_QMARK_ = clojure.core.rrb_vector.nodes.regular_QMARK_(node);\r\nvar arr = node.arr;\r\nvar rngs = (((!(reg_QMARK_)))?clojure.core.rrb_vector.nodes.node_ranges(node):null);\r\nvar i = ((start >> shift) & (31));\r\nvar i__$1 = ((reg_QMARK_)?i:(function (){var j = i;\r\nwhile(true){\r\nif((start < (rngs[j]))){\r\nreturn j;\r\n} else {\r\nvar G__32956 = (j + (1));\r\nj = G__32956;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})());\r\nvar len = ((reg_QMARK_)?(function (){var i__$2 = i__$1;\r\nwhile(true){\r\nif((((i__$2 === (32))) || (((arr[i__$2]) == null)))){\r\nreturn i__$2;\r\n} else {\r\nvar G__32957 = (i__$2 + (1));\r\ni__$2 = G__32957;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})():(rngs[(32)]));\r\nvar child_start = (((i__$1 > (0)))?(start - ((reg_QMARK_)?(i__$1 * ((1) << shift)):(rngs[(i__$1 - (1))]))):start);\r\nvar child_end = ((reg_QMARK_)?(function (){var x__4217__auto__ = ((1) << shift);\r\nvar y__4218__auto__ = (((i__$1 > (0)))?(end - (i__$1 * ((1) << shift))):end);\r\nreturn ((x__4217__auto__ < y__4218__auto__) ? x__4217__auto__ : y__4218__auto__);\r\n})():(function (){var capped_end = (function (){var x__4217__auto__ = (rngs[i__$1]);\r\nvar y__4218__auto__ = end;\r\nreturn ((x__4217__auto__ < y__4218__auto__) ? x__4217__auto__ : y__4218__auto__);\r\n})();\r\nif((i__$1 > (0))){\r\nreturn (capped_end - (rngs[(i__$1 - (1))]));\r\n} else {\r\nreturn capped_end;\r\n}\r\n})());\r\nvar new_child = (function (){var G__32868 = (arr[i__$1]);\r\nvar G__32869 = (shift - (5));\r\nvar G__32870 = child_start;\r\nvar G__32871 = child_end;\r\nreturn (clojure.core.rrb_vector.rrbt.slice_left.cljs$core$IFn$_invoke$arity$4 ? clojure.core.rrb_vector.rrbt.slice_left.cljs$core$IFn$_invoke$arity$4(G__32868,G__32869,G__32870,G__32871) : clojure.core.rrb_vector.rrbt.slice_left.call(null,G__32868,G__32869,G__32870,G__32871));\r\n})();\r\nvar new_len = (len - i__$1);\r\nvar new_len__$1 = (((new_child == null))?(new_len - (1)):new_len);\r\nif((new_len__$1 === (0))){\r\nreturn null;\r\n} else {\r\nif(reg_QMARK_){\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar rngs__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar rng0 = (((((new_child == null)) || ((shift === (5))) || (clojure.core.rrb_vector.nodes.regular_QMARK_(new_child))))?(((1) << shift) - ((start >> (shift - (5))) & (31))):clojure.core.rrb_vector.nodes.last_range(new_child));\r\nvar step = ((1) << shift);\r\nvar j_32962 = (0);\r\nvar r_32963 = rng0;\r\nwhile(true){\r\nif((j_32962 < new_len__$1)){\r\n(rngs__$1[j_32962] = r_32963);\r\n\r\nvar G__32964 = (j_32962 + (1));\r\nvar G__32965 = (r_32963 + step);\r\nj_32962 = G__32964;\r\nr_32963 = G__32965;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nif((new_len__$1 > (1))){\r\n(rngs__$1[(new_len__$1 - (1))] = (end - start));\r\n} else {\r\n}\r\n\r\n(rngs__$1[(32)] = new_len__$1);\r\n\r\ncljs.core.array_copy(arr,(((new_child == null))?(i__$1 + (1)):i__$1),new_arr,(0),new_len__$1);\r\n\r\nif((!((new_child == null)))){\r\n(new_arr[(0)] = new_child);\r\n} else {\r\n}\r\n\r\n(new_arr[(32)] = rngs__$1);\r\n\r\nreturn cljs.core.__GT_VectorNode(node.edit,new_arr);\r\n} else {\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar j_32966 = (0);\r\nvar i_32967__$2 = i__$1;\r\nwhile(true){\r\nif((j_32966 < new_len__$1)){\r\n(new_rngs[j_32966] = ((rngs[i_32967__$2]) - start));\r\n\r\nvar G__32968 = (j_32966 + (1));\r\nvar G__32969 = (i_32967__$2 + (1));\r\nj_32966 = G__32968;\r\ni_32967__$2 = G__32969;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_rngs[(32)] = new_len__$1);\r\n\r\ncljs.core.array_copy(arr,(((new_child == null))?(i__$1 + (1)):i__$1),new_arr,(0),new_len__$1);\r\n\r\nif((!((new_child == null)))){\r\n(new_arr[(0)] = new_child);\r\n} else {\r\n}\r\n\r\n(new_arr[(32)] = new_rngs);\r\n\r\nreturn cljs.core.__GT_VectorNode(node.edit,new_arr);\r\n\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n* @constructor\r\n * @implements {cljs.core.IIndexed}\r\n * @implements {cljs.core.IVector}\r\n * @implements {cljs.core.IReversible}\r\n * @implements {cljs.core.IKVReduce}\r\n * @implements {cljs.core.IEquiv}\r\n * @implements {cljs.core.IHash}\r\n * @implements {cljs.core.IFn}\r\n * @implements {cljs.core.ICollection}\r\n * @implements {cljs.core.IEditableCollection}\r\n * @implements {clojure.core.rrb_vector.rrbt.AsRRBT}\r\n * @implements {cljs.core.IEmptyableCollection}\r\n * @implements {cljs.core.ICounted}\r\n * @implements {clojure.core.rrb_vector.protocols.PSliceableVector}\r\n * @implements {cljs.core.ISeqable}\r\n * @implements {cljs.core.IMeta}\r\n * @implements {cljs.core.IStack}\r\n * @implements {cljs.core.IMapEntry}\r\n * @implements {cljs.core.IPrintWithWriter}\r\n * @implements {cljs.core.IComparable}\r\n * @implements {cljs.core.ISequential}\r\n * @implements {cljs.core.IWithMeta}\r\n * @implements {cljs.core.IAssociative}\r\n * @implements {clojure.core.rrb_vector.protocols.PSpliceableVector}\r\n * @implements {clojure.core.rrb_vector.rrbt.IVecImpl}\r\n * @implements {cljs.core.ILookup}\r\n * @implements {cljs.core.IReduce}\r\n*/\r\nclojure.core.rrb_vector.rrbt.Vector = (function (cnt,shift,root,tail,meta,__hash){\r\nthis.cnt = cnt;\r\nthis.shift = shift;\r\nthis.root = root;\r\nthis.tail = tail;\r\nthis.meta = meta;\r\nthis.__hash = __hash;\r\nthis.cljs$lang$protocol_mask$partition0$ = 2315152159;\r\nthis.cljs$lang$protocol_mask$partition1$ = 2052;\r\n});\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.toString = (function (){\r\nvar self__ = this;\r\nvar this$ = this;\r\nreturn cljs.core.pr_str_STAR_(this$);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this$,k){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this$,k,not_found){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this$,f,init){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nvar i = (0);\r\nvar j = (0);\r\nvar init__$1 = init;\r\nvar arr = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null,i);\r\nvar lim = (arr.length - (1));\r\nvar step = (lim + (1));\r\nwhile(true){\r\nvar init__$2 = (function (){var G__32876 = init__$1;\r\nvar G__32877 = (i + j);\r\nvar G__32878 = (arr[j]);\r\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__32876,G__32877,G__32878) : f.call(null,G__32876,G__32877,G__32878));\r\n})();\r\nif(cljs.core.reduced_QMARK_(init__$2)){\r\nreturn cljs.core.deref(init__$2);\r\n} else {\r\nif((j < lim)){\r\nvar G__32975 = i;\r\nvar G__32976 = (j + (1));\r\nvar G__32977 = init__$2;\r\nvar G__32978 = arr;\r\nvar G__32979 = lim;\r\nvar G__32980 = step;\r\ni = G__32975;\r\nj = G__32976;\r\ninit__$1 = G__32977;\r\narr = G__32978;\r\nlim = G__32979;\r\nstep = G__32980;\r\ncontinue;\r\n} else {\r\nvar i__$1 = (i + step);\r\nif((i__$1 < self__.cnt)){\r\nvar arr__$1 = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null,i__$1);\r\nvar len = arr__$1.length;\r\nvar lim__$1 = (len - (1));\r\nvar G__32982 = i__$1;\r\nvar G__32983 = (0);\r\nvar G__32984 = init__$2;\r\nvar G__32985 = arr__$1;\r\nvar G__32986 = lim__$1;\r\nvar G__32987 = len;\r\ni = G__32982;\r\nj = G__32983;\r\ninit__$1 = G__32984;\r\narr = G__32985;\r\nlim = G__32986;\r\nstep = G__32987;\r\ncontinue;\r\n} else {\r\nreturn init__$2;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (this$,i){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(((((0) <= i)) && ((i < self__.cnt)))){\r\nvar tail_off = (self__.cnt - self__.tail.length);\r\nif((tail_off <= i)){\r\nreturn (self__.tail[(i - tail_off)]);\r\n} else {\r\nvar i__$1 = i;\r\nvar node = self__.root;\r\nvar shift__$1 = self__.shift;\r\nwhile(true){\r\nif((shift__$1 === (0))){\r\nvar arr = node.arr;\r\nreturn (arr[((i__$1 >> shift__$1) & (31))]);\r\n} else {\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar arr = node.arr;\r\nvar idx = ((i__$1 >> shift__$1) & (31));\r\nvar i__$2 = i__$1;\r\nvar node__$1 = (arr[idx]);\r\nvar shift__$2 = (shift__$1 - (5));\r\nwhile(true){\r\nvar arr__$1 = node__$1.arr;\r\nvar idx__$1 = ((i__$2 >> shift__$2) & (31));\r\nif((shift__$2 === (0))){\r\nreturn (arr__$1[idx__$1]);\r\n} else {\r\nvar G__32998 = i__$2;\r\nvar G__33001 = (arr__$1[idx__$1]);\r\nvar G__33002 = (shift__$2 - (5));\r\ni__$2 = G__32998;\r\nnode__$1 = G__33001;\r\nshift__$2 = G__33002;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar arr = node.arr;\r\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\r\nvar idx = (function (){var j = ((i__$1 >> shift__$1) & (31));\r\nwhile(true){\r\nif((i__$1 < (rngs[j]))){\r\nreturn j;\r\n} else {\r\nvar G__33003 = (j + (1));\r\nj = G__33003;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})();\r\nvar i__$2 = (((idx === (0)))?i__$1:(i__$1 - (rngs[(idx - (1))])));\r\nvar G__33005 = i__$2;\r\nvar G__33006 = (arr[idx]);\r\nvar G__33007 = (shift__$1 - (5));\r\ni__$1 = G__33005;\r\nnode = G__33006;\r\nshift__$1 = G__33007;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (this$,i,not_found){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((((i >= (0))) && ((i < self__.cnt)))){\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null,i);\r\n} else {\r\nreturn not_found;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this$,writer,opts){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,this$__$1);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (this$,i,val){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(((((0) <= i)) && ((i < self__.cnt)))){\r\nvar tail_off = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null);\r\nif((i >= tail_off)){\r\nvar new_tail = (new Array(self__.tail.length));\r\nvar idx = (i - tail_off);\r\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),self__.tail.length);\r\n\r\n(new_tail[idx] = val);\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,new_tail,self__.meta,null));\r\n} else {\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,clojure.core.rrb_vector.trees.do_assoc(self__.shift,self__.root,i,val),self__.tail,self__.meta,null));\r\n}\r\n} else {\r\nif((i === self__.cnt)){\r\nreturn this$__$1.cljs$core$ICollection$_conj$arity$2(null,val);\r\n} else {\r\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\r\n\r\n}\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1;\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn self__.meta;\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\r\nvar self__ = this;\r\nvar ___$1 = this;\r\nreturn self__.cnt;\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMapEntry$_key$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null,(0));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IMapEntry$_val$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null,(1));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IStack$_peek$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((self__.cnt > (0))){\r\nreturn this$__$1.cljs$core$IIndexed$_nth$arity$2(null,(self__.cnt - (1)));\r\n} else {\r\nreturn null;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IStack$_pop$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((self__.cnt === (0))){\r\nthrow (new Error(\"Can't pop empty vector\"));\r\n} else {\r\nif(((1) === self__.cnt)){\r\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\r\n} else {\r\nif((self__.tail.length > (1))){\r\nvar new_tail = (new Array((self__.tail.length - (1))));\r\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),new_tail.length);\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,self__.root,new_tail,self__.meta,null));\r\n} else {\r\nvar new_tail = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null,(self__.cnt - (2)));\r\nvar root_cnt = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null);\r\nvar new_root = clojure.core.rrb_vector.trees.pop_tail(self__.shift,root_cnt,self__.root.edit,self__.root);\r\nif((new_root == null)){\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\r\n} else {\r\nif((((self__.shift > (5))) && (((new_root.arr[(1)]) == null)))){\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),(self__.shift - (5)),(new_root.arr[(0)]),new_tail,self__.meta,null));\r\n} else {\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt - (1)),self__.shift,new_root,new_tail,self__.meta,null));\r\n\r\n}\r\n}\r\n\r\n}\r\n}\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((self__.cnt > (0))){\r\nreturn (new cljs.core.RSeq(this$__$1,(self__.cnt - (1)),null));\r\n} else {\r\nreturn null;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nvar h__4238__auto__ = self__.__hash;\r\nif((!((h__4238__auto__ == null)))){\r\nreturn h__4238__auto__;\r\n} else {\r\nvar h__4238__auto____$1 = cljs.core.hash_ordered_coll(this$__$1);\r\n(self__.__hash = h__4238__auto____$1);\r\n\r\nreturn h__4238__auto____$1;\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this$,that){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.equiv_sequential(this$__$1,that);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nvar G__32879 = self__.cnt;\r\nvar G__32880 = self__.shift;\r\nvar G__32881 = clojure.core.rrb_vector.transients.editable_root(self__.root);\r\nvar G__32882 = clojure.core.rrb_vector.transients.editable_tail(self__.tail);\r\nvar G__32883 = self__.tail.length;\r\nreturn (clojure.core.rrb_vector.rrbt.__GT_Transient.cljs$core$IFn$_invoke$arity$5 ? clojure.core.rrb_vector.rrbt.__GT_Transient.cljs$core$IFn$_invoke$arity$5(G__32879,G__32880,G__32881,G__32882,G__32883) : clojure.core.rrb_vector.rrbt.__GT_Transient.call(null,G__32879,G__32880,G__32881,G__32882,G__32883));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (_){\r\nvar self__ = this;\r\nvar ___$1 = this;\r\nreturn cljs.core.with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSliceableVector$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSliceableVector$_slicev$arity$3 = (function (this$,start,end){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nvar new_cnt = (end - start);\r\nif((((start < (0))) || ((end > self__.cnt)))){\r\nthrow (new Error(\"vector index out of bounds\"));\r\n} else {\r\nif((start === end)){\r\nreturn cljs.core.empty(this$__$1);\r\n} else {\r\nif((start > end)){\r\nthrow (new Error(\"start index greater than end index\"));\r\n} else {\r\nvar tail_off = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null);\r\nif((start >= tail_off)){\r\nvar new_tail = (new Array(new_cnt));\r\ncljs.core.array_copy(self__.tail,(start - tail_off),new_tail,(0),new_cnt);\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,(5),clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\r\n} else {\r\nvar tail_cut_QMARK_ = (end > tail_off);\r\nvar new_root = ((tail_cut_QMARK_)?self__.root:clojure.core.rrb_vector.rrbt.slice_right(self__.root,self__.shift,end));\r\nvar new_root__$1 = (((start === (0)))?new_root:clojure.core.rrb_vector.rrbt.slice_left(new_root,self__.shift,start,(function (){var x__4217__auto__ = end;\r\nvar y__4218__auto__ = tail_off;\r\nreturn ((x__4217__auto__ < y__4218__auto__) ? x__4217__auto__ : y__4218__auto__);\r\n})()));\r\nvar new_tail = ((tail_cut_QMARK_)?(function (){var new_len = (end - tail_off);\r\nvar new_tail = (new Array(new_len));\r\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),new_len);\r\n\r\nreturn new_tail;\r\n})():(new clojure.core.rrb_vector.rrbt.Vector(new_cnt,self__.shift,new_root__$1,[],self__.meta,null)).clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null,(new_cnt - (1))));\r\nvar new_root__$2 = ((tail_cut_QMARK_)?new_root__$1:clojure.core.rrb_vector.trees.pop_tail(self__.shift,new_cnt,new_root__$1.edit,new_root__$1));\r\nif((new_root__$2 == null)){\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,(5),clojure.core.rrb_vector.nodes.empty_node,new_tail,self__.meta,null));\r\n} else {\r\nvar r = new_root__$2;\r\nvar s = self__.shift;\r\nwhile(true){\r\nif((((s > (5))) && (((r.arr[(1)]) == null)))){\r\nvar G__33036 = (r.arr[(0)]);\r\nvar G__33037 = (s - (5));\r\nr = G__33036;\r\ns = G__33037;\r\ncontinue;\r\n} else {\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(new_cnt,s,r,new_tail,self__.meta,null));\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n\r\n}\r\n}\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn (self__.cnt - self__.tail.length);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 = (function (this$,i){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(((((0) <= i)) && ((i < self__.cnt)))){\r\nif((i >= this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null))){\r\nreturn self__.tail;\r\n} else {\r\nvar i__$1 = i;\r\nvar node = self__.root;\r\nvar shift__$1 = self__.shift;\r\nwhile(true){\r\nif((shift__$1 === (0))){\r\nreturn node.arr;\r\n} else {\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar node__$1 = (node.arr[((i__$1 >> shift__$1) & (31))]);\r\nvar shift__$2 = (shift__$1 - (5));\r\nwhile(true){\r\nif((shift__$2 === (0))){\r\nreturn node__$1.arr;\r\n} else {\r\nvar G__33041 = (node__$1.arr[((i__$1 >> shift__$2) & (31))]);\r\nvar G__33042 = (shift__$2 - (5));\r\nnode__$1 = G__33041;\r\nshift__$2 = G__33042;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\r\nvar j = (function (){var j = ((i__$1 >> shift__$1) & (31));\r\nwhile(true){\r\nif((i__$1 < (rngs[j]))){\r\nreturn j;\r\n} else {\r\nvar G__33043 = (j + (1));\r\nj = G__33043;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})();\r\nvar i__$2 = (((j > (0)))?(i__$1 - (rngs[(j - (1))])):i__$1);\r\nvar G__33044 = i__$2;\r\nvar G__33045 = (node.arr[j]);\r\nvar G__33046 = (shift__$1 - (5));\r\ni__$1 = G__33044;\r\nnode = G__33045;\r\nshift__$1 = G__33046;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (this$,f){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(this$__$1,f);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (this$,f,start){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(this$__$1,f,start);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this$,k,v){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$IVector$_assoc_n$arity$3(null,k,v);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((self__.cnt === (0))){\r\nreturn null;\r\n} else {\r\nif((this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null) === (0))){\r\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$1(self__.tail);\r\n} else {\r\nreturn clojure.core.rrb_vector.rrbt.rrb_chunked_seq.cljs$core$IFn$_invoke$arity$3(this$__$1,(0),(0));\r\n\r\n}\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this$,meta__$1){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,self__.tail,meta__$1,self__.__hash));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this$,val){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif((self__.tail.length < (32))){\r\nvar tail_len = self__.tail.length;\r\nvar new_tail = (new Array((tail_len + (1))));\r\ncljs.core.array_copy(self__.tail,(0),new_tail,(0),tail_len);\r\n\r\n(new_tail[tail_len] = val);\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),self__.shift,self__.root,new_tail,self__.meta,null));\r\n} else {\r\nvar tail_node = cljs.core.__GT_VectorNode(self__.root.edit,self__.tail);\r\nvar new_tail = (function (){var new_arr = [null];\r\n(new_arr[(0)] = val);\r\n\r\nreturn new_arr;\r\n})();\r\nif(clojure.core.rrb_vector.nodes.overflow_QMARK_(self__.root,self__.shift,self__.cnt)){\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(self__.root)){\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\r\nvar G__32884_33053 = new_arr;\r\n(G__32884_33053[(0)] = self__.root);\r\n\r\n(G__32884_33053[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\r\n\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),(self__.shift + (5)),new_root,new_tail,self__.meta,null));\r\n} else {\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\r\nvar root_total_range = (clojure.core.rrb_vector.nodes.node_ranges(self__.root)[(31)]);\r\nvar G__32885_33054 = new_arr;\r\n(G__32885_33054[(0)] = self__.root);\r\n\r\n(G__32885_33054[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\r\n\r\n(G__32885_33054[(32)] = new_rngs);\r\n\r\n\r\nvar G__32886_33055 = new_rngs;\r\n(G__32886_33055[(0)] = root_total_range);\r\n\r\n(G__32886_33055[(1)] = (root_total_range + (32)));\r\n\r\n(G__32886_33055[(32)] = (2));\r\n\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),(self__.shift + (5)),new_root,new_tail,self__.meta,null));\r\n}\r\n} else {\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((self__.cnt + (1)),self__.shift,clojure.core.rrb_vector.trees.push_tail(self__.shift,self__.cnt,self__.root.edit,self__.root,tail_node),new_tail,self__.meta,null));\r\n}\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.call = (function() {\r\nvar G__33056 = null;\r\nvar G__33056__2 = (function (self__,k){\r\nvar self__ = this;\r\nvar self____$1 = this;\r\nvar this$ = self____$1;\r\nreturn this$.cljs$core$IIndexed$_nth$arity$2(null,k);\r\n});\r\nvar G__33056__3 = (function (self__,k,not_found){\r\nvar self__ = this;\r\nvar self____$1 = this;\r\nvar this$ = self____$1;\r\nreturn this$.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\r\n});\r\nG__33056 = function(self__,k,not_found){\r\nswitch(arguments.length){\r\ncase 2:\r\nreturn G__33056__2.call(this,self__,k);\r\ncase 3:\r\nreturn G__33056__3.call(this,self__,k,not_found);\r\n}\r\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\r\n};\r\nG__33056.cljs$core$IFn$_invoke$arity$2 = G__33056__2;\r\nG__33056.cljs$core$IFn$_invoke$arity$3 = G__33056__3;\r\nreturn G__33056;\r\n})()\r\n);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.apply = (function (self__,args32872){\r\nvar self__ = this;\r\nvar self____$1 = this;\r\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args32872)));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\r\nvar self__ = this;\r\nvar this$ = this;\r\nreturn this$.cljs$core$IIndexed$_nth$arity$2(null,k);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\r\nvar self__ = this;\r\nvar this$ = this;\r\nreturn this$.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.cljs$core$IComparable$_compare$arity$2 = (function (this$,that){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(this$__$1,that);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSpliceableVector$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.prototype.clojure$core$rrb_vector$protocols$PSpliceableVector$_splicev$arity$2 = (function (this$,that){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nvar G__32887 = this$__$1;\r\nvar G__32888 = clojure.core.rrb_vector.rrbt._as_rrbt(that);\r\nreturn (clojure.core.rrb_vector.rrbt.splice_rrbts.cljs$core$IFn$_invoke$arity$2 ? clojure.core.rrb_vector.rrbt.splice_rrbts.cljs$core$IFn$_invoke$arity$2(G__32887,G__32888) : clojure.core.rrb_vector.rrbt.splice_rrbts.call(null,G__32887,G__32888));\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.getBasis = (function (){\r\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$type = true);\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/Vector\");\r\n\r\n(clojure.core.rrb_vector.rrbt.Vector.cljs$lang$ctorPrWriter = (function (this__4369__auto__,writer__4370__auto__,opt__4371__auto__){\r\nreturn cljs.core._write(writer__4370__auto__,\"clojure.core.rrb-vector.rrbt/Vector\");\r\n}));\r\n\r\n/**\r\n * Positional factory function for clojure.core.rrb-vector.rrbt/Vector.\r\n */\r\nclojure.core.rrb_vector.rrbt.__GT_Vector = (function clojure$core$rrb_vector$rrbt$__GT_Vector(cnt,shift,root,tail,meta,__hash){\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(cnt,shift,root,tail,meta,__hash));\r\n});\r\n\r\n(cljs.core.PersistentVector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(cljs.core.PersistentVector.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\r\nvar this$__$1 = this;\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(cljs.core.count(this$__$1),this$__$1.shift,this$__$1.root,this$__$1.tail,cljs.core.meta(this$__$1),null));\r\n}));\r\n\r\n(cljs.core.Subvec.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(cljs.core.Subvec.prototype.clojure$core$rrb_vector$rrbt$AsRRBT$_as_rrbt$arity$1 = (function (this$){\r\nvar this$__$1 = this;\r\nvar v = this$__$1.v;\r\nvar start = this$__$1.start;\r\nvar end = this$__$1.end;\r\nreturn clojure.core.rrb_vector.protocols._slicev(clojure.core.rrb_vector.rrbt._as_rrbt(v),start,end);\r\n}));\r\nclojure.core.rrb_vector.rrbt.shift_from_to = (function clojure$core$rrb_vector$rrbt$shift_from_to(node,from,to){\r\nwhile(true){\r\nif((from === to)){\r\nreturn node;\r\n} else {\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar G__33066 = cljs.core.__GT_VectorNode(node.edit,(function (){var G__32889 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(G__32889[(0)] = node);\r\n\r\nreturn G__32889;\r\n})());\r\nvar G__33067 = ((5) + from);\r\nvar G__33068 = to;\r\nnode = G__33066;\r\nfrom = G__33067;\r\nto = G__33068;\r\ncontinue;\r\n} else {\r\nvar G__33069 = cljs.core.__GT_VectorNode(node.edit,(function (){var G__32890 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(G__32890[(0)] = node);\r\n\r\n(G__32890[(32)] = (function (){var G__32891 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(G__32891[(0)] = clojure.core.rrb_vector.nodes.last_range(node));\r\n\r\n(G__32891[(32)] = (1));\r\n\r\nreturn G__32891;\r\n})());\r\n\r\nreturn G__32890;\r\n})());\r\nvar G__33070 = ((5) + from);\r\nvar G__33071 = to;\r\nnode = G__33069;\r\nfrom = G__33070;\r\nto = G__33071;\r\ncontinue;\r\n\r\n}\r\n}\r\nbreak;\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.slot_count = (function clojure$core$rrb_vector$rrbt$slot_count(node,shift){\r\nvar arr = node.arr;\r\nif((shift === (0))){\r\nreturn arr.length;\r\n} else {\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nreturn clojure.core.rrb_vector.nodes.index_of_nil(arr);\r\n} else {\r\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\r\nreturn (rngs[(32)]);\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.subtree_branch_count = (function clojure$core$rrb_vector$rrbt$subtree_branch_count(node,shift){\r\nvar arr = node.arr;\r\nvar cs = (shift - (5));\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar i = (0);\r\nvar sbc = (0);\r\nwhile(true){\r\nif((i === (32))){\r\nreturn sbc;\r\n} else {\r\nvar temp__5733__auto__ = (arr[i]);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar child = temp__5733__auto__;\r\nvar G__33074 = (i + (1));\r\nvar G__33075 = (sbc + clojure.core.rrb_vector.rrbt.slot_count(child,cs));\r\ni = G__33074;\r\nsbc = G__33075;\r\ncontinue;\r\n} else {\r\nreturn sbc;\r\n}\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar lim = (clojure.core.rrb_vector.nodes.node_ranges(node)[(32)]);\r\nvar i = (0);\r\nvar sbc = (0);\r\nwhile(true){\r\nif((i === lim)){\r\nreturn sbc;\r\n} else {\r\nvar child = (arr[i]);\r\nvar G__33076 = (i + (1));\r\nvar G__33077 = (sbc + clojure.core.rrb_vector.rrbt.slot_count(child,cs));\r\ni = G__33076;\r\nsbc = G__33077;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.leaf_seq = (function clojure$core$rrb_vector$rrbt$leaf_seq(arr){\r\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p1__32892_SHARP_){\r\nreturn p1__32892_SHARP_.arr;\r\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.take.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.nodes.index_of_nil(arr),arr)], 0));\r\n});\r\nclojure.core.rrb_vector.rrbt.rebalance_leaves = (function clojure$core$rrb_vector$rrbt$rebalance_leaves(n1,cnt1,n2,cnt2,transferred_leaves){\r\nvar slc1 = clojure.core.rrb_vector.rrbt.slot_count(n1,(5));\r\nvar slc2 = clojure.core.rrb_vector.rrbt.slot_count(n2,(5));\r\nvar a = (slc1 + slc2);\r\nvar sbc1 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n1,(5));\r\nvar sbc2 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n2,(5));\r\nvar p = (sbc1 + sbc2);\r\nvar e = (a - (cljs.core.quot((p - (1)),(32)) + (1)));\r\nif((e <= (2))){\r\nreturn [n1,n2];\r\n} else {\r\nif(((sbc1 + sbc2) <= (1024))){\r\nvar reg_QMARK_ = (cljs.core.mod(p,(32)) === (0));\r\nvar new_arr = (new Array(((reg_QMARK_)?(32):(33))));\r\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr);\r\nvar i_33082 = (0);\r\nvar bs_33083 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.leaf_seq(n1.arr),clojure.core.rrb_vector.rrbt.leaf_seq(n2.arr)));\r\nwhile(true){\r\nvar temp__5735__auto___33085 = cljs.core.seq(bs_33083);\r\nif(temp__5735__auto___33085){\r\nvar xs__6292__auto___33086 = temp__5735__auto___33085;\r\nvar block_33087 = cljs.core.first(xs__6292__auto___33086);\r\nvar a_33088__$1 = (new Array(cljs.core.count(block_33087)));\r\nvar i_33089__$1 = (0);\r\nvar xs_33090 = cljs.core.seq(block_33087);\r\nwhile(true){\r\nif(xs_33090){\r\n(a_33088__$1[i_33089__$1] = cljs.core.first(xs_33090));\r\n\r\nvar G__33092 = (i_33089__$1 + (1));\r\nvar G__33093 = cljs.core.next(xs_33090);\r\ni_33089__$1 = G__33092;\r\nxs_33090 = G__33093;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_arr[i_33082] = cljs.core.__GT_VectorNode(null,a_33088__$1));\r\n\r\nvar G__33095 = (i_33082 + (1));\r\nvar G__33096 = cljs.core.next(bs_33083);\r\ni_33082 = G__33095;\r\nbs_33083 = G__33096;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nif((!(reg_QMARK_))){\r\n(new_arr[(32)] = clojure.core.rrb_vector.nodes.regular_ranges((5),p));\r\n} else {\r\n}\r\n\r\n(transferred_leaves.val = sbc2);\r\n\r\nreturn [new_n1,null];\r\n} else {\r\nvar reg_QMARK_ = (cljs.core.mod(p,(32)) === (0));\r\nvar new_arr1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_arr2 = (new Array(((reg_QMARK_)?(32):(33))));\r\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr1);\r\nvar new_n2 = cljs.core.__GT_VectorNode(null,new_arr2);\r\nvar i_33097 = (0);\r\nvar bs_33098 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.leaf_seq(n1.arr),clojure.core.rrb_vector.rrbt.leaf_seq(n2.arr)));\r\nwhile(true){\r\nvar temp__5735__auto___33100 = cljs.core.seq(bs_33098);\r\nif(temp__5735__auto___33100){\r\nvar xs__6292__auto___33102 = temp__5735__auto___33100;\r\nvar block_33103 = cljs.core.first(xs__6292__auto___33102);\r\nvar a_33104__$1 = (new Array(cljs.core.count(block_33103)));\r\nvar i_33105__$1 = (0);\r\nvar xs_33106 = cljs.core.seq(block_33103);\r\nwhile(true){\r\nif(xs_33106){\r\n(a_33104__$1[i_33105__$1] = cljs.core.first(xs_33106));\r\n\r\nvar G__33107 = (i_33105__$1 + (1));\r\nvar G__33108 = cljs.core.next(xs_33106);\r\ni_33105__$1 = G__33107;\r\nxs_33106 = G__33108;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nif((i_33097 < (32))){\r\n(new_arr1[i_33097] = cljs.core.__GT_VectorNode(null,a_33104__$1));\r\n} else {\r\n(new_arr2[(i_33097 - (32))] = cljs.core.__GT_VectorNode(null,a_33104__$1));\r\n}\r\n\r\nvar G__33109 = (i_33097 + (1));\r\nvar G__33110 = cljs.core.next(bs_33098);\r\ni_33097 = G__33109;\r\nbs_33098 = G__33110;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nif((!(reg_QMARK_))){\r\n(new_arr2[(32)] = clojure.core.rrb_vector.nodes.regular_ranges((5),(p - (1024))));\r\n} else {\r\n}\r\n\r\n(transferred_leaves.val = ((1024) - sbc1));\r\n\r\nreturn [new_n1,new_n2];\r\n\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.child_seq = (function clojure$core$rrb_vector$rrbt$child_seq(node,shift,cnt){\r\nvar arr = node.arr;\r\nvar rngs = ((clojure.core.rrb_vector.nodes.regular_QMARK_(node))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt):clojure.core.rrb_vector.nodes.node_ranges(node));\r\nvar cs = (cljs.core.truth_(rngs)?(rngs[(32)]):clojure.core.rrb_vector.nodes.index_of_nil(arr));\r\nvar cseq = (function clojure$core$rrb_vector$rrbt$child_seq_$_cseq(c,r){\r\nvar arr__$1 = c.arr;\r\nvar rngs__$1 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(c))?clojure.core.rrb_vector.nodes.regular_ranges((shift - (5)),r):clojure.core.rrb_vector.nodes.node_ranges(c));\r\nvar gcs = (cljs.core.truth_(rngs__$1)?(rngs__$1[(32)]):clojure.core.rrb_vector.nodes.index_of_nil(arr__$1));\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core.list,cljs.core.take.cljs$core$IFn$_invoke$arity$2(gcs,arr__$1),cljs.core.take.cljs$core$IFn$_invoke$arity$2(gcs,cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core._,rngs__$1,cljs.core.cons((0),rngs__$1))));\r\n});\r\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cseq,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.take.cljs$core$IFn$_invoke$arity$2(cs,arr),cljs.core.take.cljs$core$IFn$_invoke$arity$2(cs,cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core._,rngs,cljs.core.cons((0),rngs)))], 0));\r\n});\r\nclojure.core.rrb_vector.rrbt.rebalance = (function clojure$core$rrb_vector$rrbt$rebalance(shift,n1,cnt1,n2,cnt2,transferred_leaves){\r\nif((n2 == null)){\r\nreturn [n1,null];\r\n} else {\r\nvar slc1 = clojure.core.rrb_vector.rrbt.slot_count(n1,shift);\r\nvar slc2 = clojure.core.rrb_vector.rrbt.slot_count(n2,shift);\r\nvar a = (slc1 + slc2);\r\nvar sbc1 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n1,shift);\r\nvar sbc2 = clojure.core.rrb_vector.rrbt.subtree_branch_count(n2,shift);\r\nvar p = (sbc1 + sbc2);\r\nvar e = (a - (cljs.core.quot((p - (1)),(32)) + (1)));\r\nif((e <= (2))){\r\nreturn [n1,n2];\r\n} else {\r\nif(((sbc1 + sbc2) <= (1024))){\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr);\r\nvar i_33111 = (0);\r\nvar bs_33113 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.child_seq(n1,shift,cnt1),clojure.core.rrb_vector.rrbt.child_seq(n2,shift,cnt2)));\r\nwhile(true){\r\nvar temp__5735__auto___33114 = cljs.core.seq(bs_33113);\r\nif(temp__5735__auto___33114){\r\nvar xs__6292__auto___33115 = temp__5735__auto___33114;\r\nvar block_33116 = cljs.core.first(xs__6292__auto___33115);\r\nvar a_33117__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar r_33118 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(a_33117__$1[(32)] = r_33118);\r\n\r\n(r_33118[(32)] = cljs.core.count(block_33116));\r\n\r\nvar i_33122__$1 = (0);\r\nvar o_33123 = (0);\r\nvar gcs_33124 = cljs.core.seq(block_33116);\r\nwhile(true){\r\nvar temp__5735__auto___33125__$1 = cljs.core.seq(gcs_33124);\r\nif(temp__5735__auto___33125__$1){\r\nvar xs__6292__auto___33126__$1 = temp__5735__auto___33125__$1;\r\nvar vec__32893_33127 = cljs.core.first(xs__6292__auto___33126__$1);\r\nvar gc_33128 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32893_33127,(0),null);\r\nvar gcr_33129 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32893_33127,(1),null);\r\n(a_33117__$1[i_33122__$1] = gc_33128);\r\n\r\n(r_33118[i_33122__$1] = (o_33123 + gcr_33129));\r\n\r\nvar G__33131 = (i_33122__$1 + (1));\r\nvar G__33132 = (o_33123 + gcr_33129);\r\nvar G__33133 = cljs.core.next(gcs_33124);\r\ni_33122__$1 = G__33131;\r\no_33123 = G__33132;\r\ngcs_33124 = G__33133;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_arr[i_33111] = cljs.core.__GT_VectorNode(null,a_33117__$1));\r\n\r\n(new_rngs[i_33111] = ((r_33118[((r_33118[(32)]) - (1))]) + (((i_33111 > (0)))?(new_rngs[(i_33111 - (1))]):(0))));\r\n\r\n(new_rngs[(32)] = (i_33111 + (1)));\r\n\r\nvar G__33137 = (i_33111 + (1));\r\nvar G__33138 = cljs.core.next(bs_33113);\r\ni_33111 = G__33137;\r\nbs_33113 = G__33138;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_arr[(32)] = new_rngs);\r\n\r\n(transferred_leaves.val = cnt2);\r\n\r\nreturn [new_n1,null];\r\n} else {\r\nvar new_arr1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_arr2 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs2 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_n1 = cljs.core.__GT_VectorNode(null,new_arr1);\r\nvar new_n2 = cljs.core.__GT_VectorNode(null,new_arr2);\r\nvar i_33143 = (0);\r\nvar bs_33144 = cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((32),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.child_seq(n1,shift,cnt1),clojure.core.rrb_vector.rrbt.child_seq(n2,shift,cnt2)));\r\nwhile(true){\r\nvar temp__5735__auto___33145 = cljs.core.seq(bs_33144);\r\nif(temp__5735__auto___33145){\r\nvar xs__6292__auto___33146 = temp__5735__auto___33145;\r\nvar block_33147 = cljs.core.first(xs__6292__auto___33146);\r\nvar a_33148__$1 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar r_33149 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(a_33148__$1[(32)] = r_33149);\r\n\r\n(r_33149[(32)] = cljs.core.count(block_33147));\r\n\r\nvar i_33151__$1 = (0);\r\nvar o_33152 = (0);\r\nvar gcs_33153 = cljs.core.seq(block_33147);\r\nwhile(true){\r\nvar temp__5735__auto___33154__$1 = cljs.core.seq(gcs_33153);\r\nif(temp__5735__auto___33154__$1){\r\nvar xs__6292__auto___33155__$1 = temp__5735__auto___33154__$1;\r\nvar vec__32896_33156 = cljs.core.first(xs__6292__auto___33155__$1);\r\nvar gc_33157 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32896_33156,(0),null);\r\nvar gcr_33158 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32896_33156,(1),null);\r\n(a_33148__$1[i_33151__$1] = gc_33157);\r\n\r\n(r_33149[i_33151__$1] = (o_33152 + gcr_33158));\r\n\r\nvar G__33160 = (i_33151__$1 + (1));\r\nvar G__33161 = (o_33152 + gcr_33158);\r\nvar G__33162 = cljs.core.next(gcs_33153);\r\ni_33151__$1 = G__33160;\r\no_33152 = G__33161;\r\ngcs_33153 = G__33162;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nif((((i_33143 < (32))) && ((((i_33143 * (32)) + cljs.core.count(block_33147)) > sbc1)))){\r\nvar tbs_33165 = (((i_33143 * (32)) + cljs.core.count(block_33147)) - sbc1);\r\nvar li_33166 = ((r_33149[(32)]) - (1));\r\nvar d_33167 = (((tbs_33165 >= (32)))?(r_33149[li_33166]):((r_33149[li_33166]) - (r_33149[(li_33166 - tbs_33165)])));\r\n(transferred_leaves.val = (transferred_leaves.val + d_33167));\r\n} else {\r\n}\r\n\r\nvar new_arr_33169 = (((i_33143 < (32)))?new_arr1:new_arr2);\r\nvar new_rngs_33170 = (((i_33143 < (32)))?new_rngs1:new_rngs2);\r\nvar i_33171__$1 = cljs.core.mod(i_33143,(32));\r\n(new_arr_33169[i_33171__$1] = cljs.core.__GT_VectorNode(null,a_33148__$1));\r\n\r\n(new_rngs_33170[i_33171__$1] = ((r_33149[((r_33149[(32)]) - (1))]) + (((i_33171__$1 > (0)))?(new_rngs_33170[(i_33171__$1 - (1))]):(0))));\r\n\r\n(new_rngs_33170[(32)] = (i_33171__$1 + (1)));\r\n\r\nvar G__33178 = (i_33143 + (1));\r\nvar G__33179 = cljs.core.next(bs_33144);\r\ni_33143 = G__33178;\r\nbs_33144 = G__33179;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_arr1[(32)] = new_rngs1);\r\n\r\n(new_arr2[(32)] = new_rngs2);\r\n\r\nreturn [new_n1,new_n2];\r\n\r\n}\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.zippath = (function clojure$core$rrb_vector$rrbt$zippath(shift,n1,cnt1,n2,cnt2,transferred_leaves){\r\nif((shift === (5))){\r\nreturn clojure.core.rrb_vector.rrbt.rebalance_leaves(n1,cnt1,n2,cnt2,transferred_leaves);\r\n} else {\r\nvar c1 = clojure.core.rrb_vector.nodes.last_child(n1);\r\nvar c2 = clojure.core.rrb_vector.nodes.first_child(n2);\r\nvar ccnt1 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(n1))?(function (){var m = cljs.core.mod(cnt1,((1) << shift));\r\nif((m === (0))){\r\nreturn ((1) << shift);\r\n} else {\r\nreturn m;\r\n}\r\n})():(function (){var rngs = clojure.core.rrb_vector.nodes.node_ranges(n1);\r\nvar i = ((rngs[(32)]) - (1));\r\nif((i === (0))){\r\nreturn (rngs[(0)]);\r\n} else {\r\nreturn ((rngs[i]) - (rngs[(i - (1))]));\r\n}\r\n})());\r\nvar ccnt2 = ((clojure.core.rrb_vector.nodes.regular_QMARK_(n2))?(function (){var m = cljs.core.mod(cnt2,((1) << shift));\r\nif((m === (0))){\r\nreturn ((1) << shift);\r\n} else {\r\nreturn m;\r\n}\r\n})():(clojure.core.rrb_vector.nodes.node_ranges(n2)[(0)]));\r\nvar next_transferred_leaves = (new cljs.core.Box((0)));\r\nvar vec__32899 = (function (){var G__32902 = (shift - (5));\r\nvar G__32903 = c1;\r\nvar G__32904 = ccnt1;\r\nvar G__32905 = c2;\r\nvar G__32906 = ccnt2;\r\nvar G__32907 = next_transferred_leaves;\r\nreturn (clojure.core.rrb_vector.rrbt.zippath.cljs$core$IFn$_invoke$arity$6 ? clojure.core.rrb_vector.rrbt.zippath.cljs$core$IFn$_invoke$arity$6(G__32902,G__32903,G__32904,G__32905,G__32906,G__32907) : clojure.core.rrb_vector.rrbt.zippath.call(null,G__32902,G__32903,G__32904,G__32905,G__32906,G__32907));\r\n})();\r\nvar new_c1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32899,(0),null);\r\nvar new_c2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32899,(1),null);\r\nvar d = next_transferred_leaves.val;\r\n(transferred_leaves.val = (transferred_leaves.val + d));\r\n\r\nreturn clojure.core.rrb_vector.rrbt.rebalance(shift,(((c1 === new_c1))?n1:clojure.core.rrb_vector.nodes.replace_rightmost_child(shift,n1,new_c1,d)),(cnt1 + d),(cljs.core.truth_(new_c2)?(((c2 === new_c2))?n2:clojure.core.rrb_vector.nodes.replace_leftmost_child(shift,n2,cnt2,new_c2,d)):clojure.core.rrb_vector.nodes.remove_leftmost_child(shift,n2)),(cnt2 - d),transferred_leaves);\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.squash_nodes = (function clojure$core$rrb_vector$rrbt$squash_nodes(shift,n1,cnt1,n2,cnt2){\r\nvar arr1 = n1.arr;\r\nvar arr2 = n2.arr;\r\nvar li1 = clojure.core.rrb_vector.nodes.index_of_nil(arr1);\r\nvar li2 = clojure.core.rrb_vector.nodes.index_of_nil(arr2);\r\nvar slots = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(li1,arr1),cljs.core.take.cljs$core$IFn$_invoke$arity$2(li2,arr2));\r\nif((cljs.core.count(slots) > (32))){\r\nreturn [n1,n2];\r\n} else {\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar rngs1 = cljs.core.take.cljs$core$IFn$_invoke$arity$2(li1,((clojure.core.rrb_vector.nodes.regular_QMARK_(n1))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt1):clojure.core.rrb_vector.nodes.node_ranges(n1)));\r\nvar rngs2 = cljs.core.take.cljs$core$IFn$_invoke$arity$2(li2,((clojure.core.rrb_vector.nodes.regular_QMARK_(n2))?clojure.core.rrb_vector.nodes.regular_ranges(shift,cnt2):clojure.core.rrb_vector.nodes.node_ranges(n2)));\r\nvar rngs2__$1 = (function (){var r = cljs.core.last(rngs1);\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__32908_SHARP_){\r\nreturn (p1__32908_SHARP_ + r);\r\n}),rngs2);\r\n})();\r\nvar rngs = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(rngs1,rngs2__$1);\r\n(new_arr[(32)] = new_rngs);\r\n\r\nvar i_33184 = (0);\r\nvar cs_33185 = cljs.core.seq(slots);\r\nwhile(true){\r\nif(cs_33185){\r\n(new_arr[i_33184] = cljs.core.first(cs_33185));\r\n\r\nvar G__33186 = (i_33184 + (1));\r\nvar G__33187 = cljs.core.next(cs_33185);\r\ni_33184 = G__33186;\r\ncs_33185 = G__33187;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar i_33188 = (0);\r\nvar rngs_33189__$1 = cljs.core.seq(rngs);\r\nwhile(true){\r\nif(rngs_33189__$1){\r\n(new_rngs[i_33188] = cljs.core.first(rngs_33189__$1));\r\n\r\nvar G__33190 = (i_33188 + (1));\r\nvar G__33191 = cljs.core.next(rngs_33189__$1);\r\ni_33188 = G__33190;\r\nrngs_33189__$1 = G__33191;\r\ncontinue;\r\n} else {\r\n(new_rngs[(32)] = i_33188);\r\n}\r\nbreak;\r\n}\r\n\r\nreturn [cljs.core.__GT_VectorNode(null,new_arr),null];\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.peephole_optimization_config = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250),null], null));\r\nclojure.core.rrb_vector.rrbt.peephole_optimization_count = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\r\nclojure.core.rrb_vector.rrbt.child_nodes = (function clojure$core$rrb_vector$rrbt$child_nodes(node){\r\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((32),cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.complement(cljs.core.nil_QMARK_),node.arr));\r\n});\r\nclojure.core.rrb_vector.rrbt.bounded_grandchildren = (function clojure$core$rrb_vector$rrbt$bounded_grandchildren(children){\r\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((33),cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(clojure.core.rrb_vector.rrbt.child_nodes,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([children], 0)));\r\n});\r\nclojure.core.rrb_vector.rrbt.last_non_nil_idx = (function clojure$core$rrb_vector$rrbt$last_non_nil_idx(arr){\r\nvar i = (arr.length - (1));\r\nwhile(true){\r\nif((i < (0))){\r\nreturn i;\r\n} else {\r\nif(((arr[i]) == null)){\r\nvar G__33197 = (i - (1));\r\ni = G__33197;\r\ncontinue;\r\n} else {\r\nreturn i;\r\n}\r\n}\r\nbreak;\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.count_vector_elements_beneath = (function clojure$core$rrb_vector$rrbt$count_vector_elements_beneath(node,shift){\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar node__$1 = node;\r\nvar shift__$1 = shift;\r\nvar acc = (0);\r\nwhile(true){\r\nif((shift__$1 === (0))){\r\nif((node__$1 == null)){\r\nreturn acc;\r\n} else {\r\nreturn (acc + (32));\r\n}\r\n} else {\r\nvar arr = node__$1.arr;\r\nvar max_child_idx = clojure.core.rrb_vector.rrbt.last_non_nil_idx(arr);\r\nvar num_elems_in_full_child = ((1) << shift__$1);\r\nif((max_child_idx < (0))){\r\nreturn acc;\r\n} else {\r\nvar G__33199 = (arr[max_child_idx]);\r\nvar G__33200 = (shift__$1 - (5));\r\nvar G__33201 = (acc + (max_child_idx * num_elems_in_full_child));\r\nnode__$1 = G__33199;\r\nshift__$1 = G__33200;\r\nacc = G__33201;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\r\nreturn (rngs[((rngs[(32)]) - (1))]);\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.peephole_optimize_root = (function clojure$core$rrb_vector$rrbt$peephole_optimize_root(v){\r\nvar config = cljs.core.deref(clojure.core.rrb_vector.rrbt.peephole_optimization_config);\r\nif((v.shift <= (10))){\r\nreturn v;\r\n} else {\r\nvar root = v.root;\r\nvar children = clojure.core.rrb_vector.rrbt.child_nodes(root);\r\nvar grandchildren = clojure.core.rrb_vector.rrbt.bounded_grandchildren(children);\r\nvar num_granchildren_bounded = cljs.core.count(grandchildren);\r\nvar many_grandchildren_QMARK_ = (num_granchildren_bounded > (32));\r\nif(many_grandchildren_QMARK_){\r\nreturn v;\r\n} else {\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_root = cljs.core.__GT_VectorNode(root.edit,new_arr);\r\nvar shift = v.shift;\r\nvar grandchild_shift = (shift - ((2) * (5)));\r\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.peephole_optimization_count,cljs.core.inc);\r\n\r\nvar idx_33207 = (0);\r\nvar remaining_gc_33208 = grandchildren;\r\nvar elem_sum_33209 = (0);\r\nwhile(true){\r\nvar temp__5733__auto___33210 = cljs.core.seq(remaining_gc_33208);\r\nif(temp__5733__auto___33210){\r\nvar remaining_gc_33211__$1 = temp__5733__auto___33210;\r\nvar grandchild_33212 = cljs.core.first(remaining_gc_33211__$1);\r\nvar num_elems_this_grandchild_33213 = clojure.core.rrb_vector.rrbt.count_vector_elements_beneath(grandchild_33212,grandchild_shift);\r\nvar next_elem_sum_33214 = (elem_sum_33209 + num_elems_this_grandchild_33213);\r\n(new_arr[idx_33207] = grandchild_33212);\r\n\r\n(new_rngs[idx_33207] = next_elem_sum_33214);\r\n\r\nvar G__33215 = (idx_33207 + (1));\r\nvar G__33216 = cljs.core.rest(remaining_gc_33211__$1);\r\nvar G__33217 = next_elem_sum_33214;\r\nidx_33207 = G__33215;\r\nremaining_gc_33208 = G__33216;\r\nelem_sum_33209 = G__33217;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\n(new_rngs[(32)] = num_granchildren_bounded);\r\n\r\n(new_arr[(32)] = new_rngs);\r\n\r\nvar new_v = (new clojure.core.rrb_vector.rrbt.Vector(v.cnt,(shift - (5)),new_root,v.tail,v.meta,null));\r\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\r\nvar fexpr__32909_33220 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\r\n(fexpr__32909_33220.cljs$core$IFn$_invoke$arity$2 ? fexpr__32909_33220.cljs$core$IFn$_invoke$arity$2(v,new_v) : fexpr__32909_33220.call(null,v,new_v));\r\n} else {\r\n}\r\n\r\nreturn new_v;\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.max_vector_elements = (2147483647);\r\nclojure.core.rrb_vector.rrbt.shift_too_large_QMARK_ = (function clojure$core$rrb_vector$rrbt$shift_too_large_QMARK_(v){\r\nreturn (v.shift > (30));\r\n});\r\nclojure.core.rrb_vector.rrbt.poor_branching_QMARK_ = (function clojure$core$rrb_vector$rrbt$poor_branching_QMARK_(v){\r\nvar tail_off = clojure.core.rrb_vector.rrbt._tail_offset(v);\r\nif((tail_off === (0))){\r\nreturn false;\r\n} else {\r\nvar shift_amount = (v.shift - (5));\r\nvar max_capacity_divided_by_1024 = ((1) << shift_amount);\r\nreturn (tail_off < max_capacity_divided_by_1024);\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.fallback_config = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250),null], null));\r\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count1 = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\r\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count2 = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\r\nclojure.core.rrb_vector.rrbt.fallback_to_slow_splice_if_needed = (function clojure$core$rrb_vector$rrbt$fallback_to_slow_splice_if_needed(v1,v2,splice_result){\r\nvar config = cljs.core.deref(clojure.core.rrb_vector.rrbt.fallback_config);\r\nif(((clojure.core.rrb_vector.rrbt.shift_too_large_QMARK_(splice_result)) || (clojure.core.rrb_vector.rrbt.poor_branching_QMARK_(splice_result)))){\r\n\r\nif(clojure.core.rrb_vector.rrbt.poor_branching_QMARK_(v1)){\r\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count1,cljs.core.inc);\r\n\r\n\r\nvar new_splice_result = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.empty(v1),v1),v2);\r\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\r\nvar fexpr__32910_33223 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\r\n(fexpr__32910_33223.cljs$core$IFn$_invoke$arity$2 ? fexpr__32910_33223.cljs$core$IFn$_invoke$arity$2(splice_result,new_splice_result) : fexpr__32910_33223.call(null,splice_result,new_splice_result));\r\n} else {\r\n}\r\n\r\nreturn new_splice_result;\r\n} else {\r\nvar new_splice_result = cljs.core.into.cljs$core$IFn$_invoke$arity$2(v1,v2);\r\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_count2,cljs.core.inc);\r\n\r\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config))){\r\nvar fexpr__32911_33224 = new cljs.core.Keyword(null,\"debug-fn\",\"debug-fn\",777839250).cljs$core$IFn$_invoke$arity$1(config);\r\n(fexpr__32911_33224.cljs$core$IFn$_invoke$arity$2 ? fexpr__32911_33224.cljs$core$IFn$_invoke$arity$2(splice_result,new_splice_result) : fexpr__32911_33224.call(null,splice_result,new_splice_result));\r\n} else {\r\n}\r\n\r\nreturn new_splice_result;\r\n}\r\n} else {\r\nreturn splice_result;\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.splice_rrbts_main = (function clojure$core$rrb_vector$rrbt$splice_rrbts_main(v1,v2){\r\nif((cljs.core.count(v1) === (0))){\r\nreturn v2;\r\n} else {\r\nif(((cljs.core.count(v1) + cljs.core.count(v2)) > clojure.core.rrb_vector.rrbt.max_vector_elements)){\r\nvar c1 = cljs.core.count(v1);\r\nvar c2 = cljs.core.count(v2);\r\nthrow (new Error([\"Attempted to concatenate two vectors whose total\",\" number of elements is \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((c1 + c2)),\", which is\",\" larger than the maximum number of elements \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(clojure.core.rrb_vector.rrbt.max_vector_elements),\" supported in a vector \"].join('')));\r\n} else {\r\nif((cljs.core.count(v2) < (33))){\r\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(v1,v2);\r\n} else {\r\nvar s1 = v1.shift;\r\nvar s2 = v2.shift;\r\nvar r1 = v1.root;\r\nvar o_QMARK_ = clojure.core.rrb_vector.nodes.overflow_QMARK_(r1,s1,(cljs.core.count(v1) + ((32) - v1.tail.length)));\r\nvar r1__$1 = ((o_QMARK_)?(function (){var tail = v1.tail;\r\nvar tail_node = cljs.core.__GT_VectorNode(null,tail);\r\nvar reg_QMARK_ = ((clojure.core.rrb_vector.nodes.regular_QMARK_(r1)) && ((tail.length === (32))));\r\nvar arr = (new Array(((reg_QMARK_)?(32):(33))));\r\n(arr[(0)] = r1);\r\n\r\n(arr[(1)] = clojure.core.rrb_vector.nodes.new_path_STAR_(s1,tail_node));\r\n\r\nif((!(reg_QMARK_))){\r\nvar rngs_33225 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(rngs_33225[(32)] = (2));\r\n\r\n(rngs_33225[(0)] = (cljs.core.count(v1) - tail.length));\r\n\r\n(rngs_33225[(1)] = cljs.core.count(v1));\r\n\r\n(arr[(32)] = rngs_33225);\r\n} else {\r\n}\r\n\r\nreturn cljs.core.__GT_VectorNode(null,arr);\r\n})():clojure.core.rrb_vector.nodes.fold_tail(r1,s1,clojure.core.rrb_vector.rrbt._tail_offset(v1),v1.tail));\r\nvar s1__$1 = ((o_QMARK_)?(s1 + (5)):s1);\r\nvar r2 = v2.root;\r\nvar s = (function (){var x__4214__auto__ = s1__$1;\r\nvar y__4215__auto__ = s2;\r\nreturn ((x__4214__auto__ > y__4215__auto__) ? x__4214__auto__ : y__4215__auto__);\r\n})();\r\nvar r1__$2 = clojure.core.rrb_vector.rrbt.shift_from_to(r1__$1,s1__$1,s);\r\nvar r2__$1 = clojure.core.rrb_vector.rrbt.shift_from_to(r2,s2,s);\r\nvar transferred_leaves = (new cljs.core.Box((0)));\r\nvar vec__32912 = clojure.core.rrb_vector.rrbt.zippath(s,r1__$2,cljs.core.count(v1),r2__$1,(cljs.core.count(v2) - v2.tail.length),transferred_leaves);\r\nvar n1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32912,(0),null);\r\nvar n2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32912,(1),null);\r\nvar d = transferred_leaves.val;\r\nvar ncnt1 = (cljs.core.count(v1) + d);\r\nvar ncnt2 = ((cljs.core.count(v2) - v2.tail.length) - d);\r\nvar vec__32915 = (((n2 === r2__$1))?clojure.core.rrb_vector.rrbt.squash_nodes(s,n1,ncnt1,n2,ncnt2):[n1,n2]);\r\nvar n1__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32915,(0),null);\r\nvar n2__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__32915,(1),null);\r\nvar ncnt1__$1 = (cljs.core.truth_(n2__$1)?ncnt1:(ncnt1 + ncnt2));\r\nvar ncnt2__$1 = (cljs.core.truth_(n2__$1)?ncnt2:(0));\r\nif(cljs.core.truth_(n2__$1)){\r\nvar arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_root = cljs.core.__GT_VectorNode(null,arr);\r\n(arr[(0)] = n1__$1);\r\n\r\n(arr[(1)] = n2__$1);\r\n\r\n(arr[(32)] = (function (){var G__32918 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(G__32918[(0)] = ncnt1__$1);\r\n\r\n(G__32918[(1)] = (ncnt1__$1 + ncnt2__$1));\r\n\r\n(G__32918[(32)] = (2));\r\n\r\nreturn G__32918;\r\n})());\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((cljs.core.count(v1) + cljs.core.count(v2)),(s + (5)),new_root,v2.tail,null,null));\r\n} else {\r\nvar r = n1__$1;\r\nvar s__$1 = s;\r\nwhile(true){\r\nif((((s__$1 > (5))) && (((r.arr[(1)]) == null)))){\r\nvar G__33230 = (r.arr[(0)]);\r\nvar G__33231 = (s__$1 - (5));\r\nr = G__33230;\r\ns__$1 = G__33231;\r\ncontinue;\r\n} else {\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector((cljs.core.count(v1) + cljs.core.count(v2)),s__$1,r,v2.tail,null,null));\r\n}\r\nbreak;\r\n}\r\n}\r\n\r\n}\r\n}\r\n}\r\n});\r\nclojure.core.rrb_vector.rrbt.splice_rrbts = (function clojure$core$rrb_vector$rrbt$splice_rrbts(v1,v2){\r\nvar r1 = clojure.core.rrb_vector.rrbt.splice_rrbts_main(v1,v2);\r\nvar r2 = clojure.core.rrb_vector.rrbt.peephole_optimize_root(r1);\r\nreturn clojure.core.rrb_vector.rrbt.fallback_to_slow_splice_if_needed(v1,v2,r2);\r\n});\r\n\r\n/**\r\n* @constructor\r\n * @implements {cljs.core.ICounted}\r\n * @implements {cljs.core.ITransientCollection}\r\n * @implements {cljs.core.ITransientVector}\r\n * @implements {cljs.core.ITransientAssociative}\r\n * @implements {clojure.core.rrb_vector.rrbt.IVecImpl}\r\n*/\r\nclojure.core.rrb_vector.rrbt.Transient = (function (cnt,shift,root,tail,tidx){\r\nthis.cnt = cnt;\r\nthis.shift = shift;\r\nthis.root = root;\r\nthis.tail = tail;\r\nthis.tidx = tidx;\r\nthis.cljs$lang$protocol_mask$partition1$ = 88;\r\nthis.cljs$lang$protocol_mask$partition0$ = 2;\r\n});\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (this$,o){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(self__.root.edit){\r\nif((self__.tidx < (32))){\r\n(self__.tail[self__.tidx] = o);\r\n\r\n(self__.cnt = (self__.cnt + (1)));\r\n\r\n(self__.tidx = (self__.tidx + (1)));\r\n\r\nreturn this$__$1;\r\n} else {\r\nvar tail_node = cljs.core.__GT_VectorNode(self__.root.edit,self__.tail);\r\nvar new_tail = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\n(new_tail[(0)] = o);\r\n\r\n(self__.tail = new_tail);\r\n\r\n(self__.tidx = (1));\r\n\r\nif(clojure.core.rrb_vector.nodes.overflow_QMARK_(self__.root,self__.shift,self__.cnt)){\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(self__.root)){\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar G__32919_33233 = new_arr;\r\n(G__32919_33233[(0)] = self__.root);\r\n\r\n(G__32919_33233[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\r\n\r\n\r\n(self__.root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr));\r\n\r\n(self__.shift = (self__.shift + (5)));\r\n\r\n(self__.cnt = (self__.cnt + (1)));\r\n\r\nreturn this$__$1;\r\n} else {\r\nvar new_arr = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_rngs = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\r\nvar new_root = cljs.core.__GT_VectorNode(self__.root.edit,new_arr);\r\nvar root_total_range = (clojure.core.rrb_vector.nodes.node_ranges(self__.root)[(31)]);\r\nvar G__32920_33236 = new_arr;\r\n(G__32920_33236[(0)] = self__.root);\r\n\r\n(G__32920_33236[(1)] = clojure.core.rrb_vector.trees.new_path(self__.tail,self__.root.edit,self__.shift,tail_node));\r\n\r\n(G__32920_33236[(32)] = new_rngs);\r\n\r\n\r\nvar G__32921_33237 = new_rngs;\r\n(G__32921_33237[(0)] = root_total_range);\r\n\r\n(G__32921_33237[(1)] = (root_total_range + (32)));\r\n\r\n(G__32921_33237[(32)] = (2));\r\n\r\n\r\n(self__.root = new_root);\r\n\r\n(self__.shift = (self__.shift + (5)));\r\n\r\n(self__.cnt = (self__.cnt + (1)));\r\n\r\nreturn this$__$1;\r\n}\r\n} else {\r\nvar new_root = clojure.core.rrb_vector.transients.push_tail_BANG_(self__.shift,self__.cnt,self__.root.edit,self__.root,tail_node);\r\n(self__.root = new_root);\r\n\r\n(self__.cnt = (self__.cnt + (1)));\r\n\r\nreturn this$__$1;\r\n}\r\n}\r\n} else {\r\nthrow (new Error(\"conj! after persistent!\"));\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(self__.root.edit){\r\n(self__.root.edit = null);\r\n\r\nvar trimmed_tail = (new Array(self__.tidx));\r\ncljs.core.array_copy(self__.tail,(0),trimmed_tail,(0),self__.tidx);\r\n\r\nreturn (new clojure.core.rrb_vector.rrbt.Vector(self__.cnt,self__.shift,self__.root,trimmed_tail,null,null));\r\n} else {\r\nthrow (new Error(\"persistent! called twice\"));\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 = (function (this$,key,val){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn this$__$1.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(null,key,val);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 = (function (this$,i,val){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(self__.root.edit){\r\nif(((((0) <= i)) && ((i < self__.cnt)))){\r\nvar tail_off = (self__.cnt - self__.tidx);\r\nif((tail_off <= i)){\r\n(self__.tail[(i - tail_off)] = val);\r\n} else {\r\n(self__.root = clojure.core.rrb_vector.transients.do_assoc_BANG_(self__.shift,self__.root.edit,self__.root,i,val));\r\n}\r\n\r\nreturn this$__$1;\r\n} else {\r\nif((i === self__.cnt)){\r\nreturn this$__$1.cljs$core$ITransientCollection$_conj_BANG_$arity$2(null,val);\r\n} else {\r\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\r\n\r\n}\r\n}\r\n} else {\r\nthrow (new Error(\"assoc! after persistent!\"));\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ITransientVector$_pop_BANG_$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(self__.root.edit){\r\nif((self__.cnt === (0))){\r\nthrow (new Error(\"Can't pop empty vector\"));\r\n} else {\r\nif(((1) === self__.cnt)){\r\n(self__.cnt = (0));\r\n\r\n(self__.tidx = (0));\r\n\r\n(self__.tail[(0)] = null);\r\n\r\nreturn this$__$1;\r\n} else {\r\nif((self__.tidx > (1))){\r\n(self__.cnt = (self__.cnt - (1)));\r\n\r\n(self__.tidx = (self__.tidx - (1)));\r\n\r\n(self__.tail[self__.tidx] = null);\r\n\r\nreturn this$__$1;\r\n} else {\r\nvar new_tail_base = this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2(null,(self__.cnt - (2)));\r\nvar new_tail = clojure.core.rrb_vector.transients.editable_tail(new_tail_base);\r\nvar new_tidx = new_tail_base.length;\r\nvar new_root = clojure.core.rrb_vector.transients.pop_tail_BANG_(self__.shift,self__.cnt,self__.root.edit,self__.root);\r\nif((new_root == null)){\r\n(self__.cnt = (self__.cnt - (1)));\r\n\r\n(self__.root = clojure.core.rrb_vector.transients.ensure_editable(self__.root.edit,clojure.core.rrb_vector.nodes.empty_node));\r\n\r\n(self__.tail = new_tail);\r\n\r\n(self__.tidx = new_tidx);\r\n\r\nreturn this$__$1;\r\n} else {\r\nif((((self__.shift > (5))) && (((new_root.arr[(1)]) == null)))){\r\n(self__.cnt = (self__.cnt - (1)));\r\n\r\n(self__.shift = (self__.shift - (5)));\r\n\r\n(self__.root = clojure.core.rrb_vector.transients.ensure_editable(self__.root.edit,(new_root.arr[(0)])));\r\n\r\n(self__.tail = new_tail);\r\n\r\n(self__.tidx = new_tidx);\r\n\r\nreturn this$__$1;\r\n} else {\r\n(self__.cnt = (self__.cnt - (1)));\r\n\r\n(self__.root = new_root);\r\n\r\n(self__.tail = new_tail);\r\n\r\n(self__.tidx = new_tidx);\r\n\r\nreturn this$__$1;\r\n\r\n}\r\n}\r\n\r\n}\r\n}\r\n}\r\n} else {\r\nthrow (new Error(\"count after persistent!\"));\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.cljs$core$ICounted$_count$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(self__.root.edit){\r\nreturn self__.cnt;\r\n} else {\r\nthrow (new Error(\"count after persistent!\"));\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$ = cljs.core.PROTOCOL_SENTINEL);\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1 = (function (this$){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nreturn (self__.cnt - self__.tidx);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.prototype.clojure$core$rrb_vector$rrbt$IVecImpl$_array_for$arity$2 = (function (this$,i){\r\nvar self__ = this;\r\nvar this$__$1 = this;\r\nif(((((0) <= i)) && ((i < self__.cnt)))){\r\nif((i >= this$__$1.clojure$core$rrb_vector$rrbt$IVecImpl$_tail_offset$arity$1(null))){\r\nreturn self__.tail;\r\n} else {\r\nvar i__$1 = i;\r\nvar node = self__.root;\r\nvar shift__$1 = self__.shift;\r\nwhile(true){\r\nif((shift__$1 === (0))){\r\nreturn node.arr;\r\n} else {\r\nif(clojure.core.rrb_vector.nodes.regular_QMARK_(node)){\r\nvar node__$1 = (node.arr[((i__$1 >> shift__$1) & (31))]);\r\nvar shift__$2 = (shift__$1 - (5));\r\nwhile(true){\r\nif((shift__$2 === (0))){\r\nreturn node__$1.arr;\r\n} else {\r\nvar G__33243 = (node__$1.arr[((i__$1 >> shift__$2) & (31))]);\r\nvar G__33244 = (shift__$2 - (5));\r\nnode__$1 = G__33243;\r\nshift__$2 = G__33244;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nvar rngs = clojure.core.rrb_vector.nodes.node_ranges(node);\r\nvar j = (function (){var j = ((i__$1 >> shift__$1) & (31));\r\nwhile(true){\r\nif((i__$1 < (rngs[j]))){\r\nreturn j;\r\n} else {\r\nvar G__33246 = (j + (1));\r\nj = G__33246;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n})();\r\nvar i__$2 = (((j > (0)))?(i__$1 - (rngs[(j - (1))])):i__$1);\r\nvar G__33247 = i__$2;\r\nvar G__33248 = (node.arr[j]);\r\nvar G__33249 = (shift__$1 - (5));\r\ni__$1 = G__33247;\r\nnode = G__33248;\r\nshift__$1 = G__33249;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nreturn cljs.core.vector_index_out_of_bounds(i,self__.cnt);\r\n}\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.getBasis = (function (){\r\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"tidx\",\"tidx\",1939123455,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\r\n}));\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$type = true);\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$ctorStr = \"clojure.core.rrb-vector.rrbt/Transient\");\r\n\r\n(clojure.core.rrb_vector.rrbt.Transient.cljs$lang$ctorPrWriter = (function (this__4369__auto__,writer__4370__auto__,opt__4371__auto__){\r\nreturn cljs.core._write(writer__4370__auto__,\"clojure.core.rrb-vector.rrbt/Transient\");\r\n}));\r\n\r\n/**\r\n * Positional factory function for clojure.core.rrb-vector.rrbt/Transient.\r\n */\r\nclojure.core.rrb_vector.rrbt.__GT_Transient = (function clojure$core$rrb_vector$rrbt$__GT_Transient(cnt,shift,root,tail,tidx){\r\nreturn (new clojure.core.rrb_vector.rrbt.Transient(cnt,shift,root,tail,tidx));\r\n});\r\n\r\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/core/rrb_vector/rrbt.cljs","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",33],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$dbg","~$clojure.core.rrb-vector.macros"],"~:excludes",["~#set",["~$push-tail","~$new-path","~$do-assoc","~$pop-tail","~$array-for"]],"~:name","~$clojure.core.rrb-vector.rrbt","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.core.rrb-vector.protocols","^V","~$clojure.core.rrb-vector.nodes","^W","~$clojure.core.rrb-vector.trees","^X","~$clojure.core.rrb-vector.transients","^Y","~$cljs.core","^Z","~$goog","^["],"~:seen",["^J",["~:require","~:require-macros"]],"~:uses",["^ ","~$editable-root","^Y","~$push-tail!","^Y","~$do-assoc!","^Y","~$regular?","^W","~$ensure-editable","^Y","^K","^X","~$remove-leftmost-child","^W","~$last-range","^W","~$node-ranges","^W","~$first-child","^W","~$new-path*","^W","^L","^X","~$editable-tail","^Y","^M","^X","~$regular-ranges","^W","~$-slicev","^V","~$fold-tail","^W","~$PSliceableVector","^V","^N","^X","~$index-of-nil","^W","~$overflow?","^W","~$empty-node","^W","~$replace-leftmost-child","^W","~$-splicev","^V","~$last-child","^W","~$PSpliceableVector","^V","~$pop-tail!","^Y","~$replace-rightmost-child","^W"],"^12",["^ ","^H","^H","^Z","^Z"],"~:form",["~#list",["~$ns","^Q",["^1M",["~:refer-clojure","~:exclude",["^O","^K","^N","^L","^M"]]],["^1M",["^11",["^V","~:refer",["^1B","^1@","^1I","^1G"]],["^W","^1Q",["^17","^1E","^1;","^1D","^1:","^1?","^1<","^1H","^19","^1F","^1K","^1A","^1=","^1C"]],["^X","^1Q",["^K","^N","^L","^M"]],["^Y","^1Q",["^18","^14","^1>","^15","^1J","^16"]]]],["^1M",["^12",["^H","^1Q",["^G"]]]]]],"~:flags",["^ ","^11",["^J",[]],"^12",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^[","^Z","^V","^W","^X","^Y"]],"^S","^Q","~:resource-id",["~:shadow.build.classpath/resource","clojure/core/rrb_vector/rrbt.cljs"],"~:compiled-at",1698266499509,"~:resource-name","clojure/core/rrb_vector/rrbt.cljs","~:warnings",[],"~:source","(ns clojure.core.rrb-vector.rrbt\n  (:refer-clojure :exclude [array-for push-tail pop-tail new-path do-assoc])\n  (:require [clojure.core.rrb-vector.protocols\n             :refer [PSliceableVector -slicev\n                     PSpliceableVector -splicev]]\n            [clojure.core.rrb-vector.nodes\n             :refer [regular? empty-node node-ranges overflow? last-range\n                     regular-ranges first-child last-child remove-leftmost-child\n                     replace-leftmost-child replace-rightmost-child\n                     fold-tail new-path* index-of-nil]]\n            [clojure.core.rrb-vector.trees\n             :refer [push-tail pop-tail new-path do-assoc]]\n            [clojure.core.rrb-vector.transients\n             :refer [ensure-editable editable-root editable-tail push-tail!\n                     pop-tail! do-assoc!]])\n  (:require-macros [clojure.core.rrb-vector.macros :refer [dbg]]))\n\n(def ^:const rrbt-concat-threshold 33)\n(def ^:const max-extra-search-steps 2)\n\n(defprotocol IVecImpl\n  (-tail-offset [v])\n  (-array-for [v i]))\n\n(defprotocol AsRRBT\n  (-as-rrbt [v]))\n\n;;; chunked seqs: can't reuse cljs.core's without tweaks, since rrb\n;;; vectors have a different array-for\n\n(declare rrb-chunked-seq)\n\n(deftype RRBChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IPrintWithWriter\n  (-pr-writer [this writer opts]\n    (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts this))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (rrb-chunked-seq vec node i off m))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (rrb-chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (rrb-chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta cljs.core.List.EMPTY meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n\n  (-chunked-rest [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (rrb-chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        ()\n        s)))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (rrb-chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        nil\n        s)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (cljs.core/subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (cljs.core/subvec vec (+ i off) (count vec)) f start)))\n\n(defn rrb-chunked-seq\n  ([vec i off]\n     (RRBChunkedSeq. vec (-array-for vec i) i off nil nil))\n  ([vec node i off]\n     (RRBChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (RRBChunkedSeq. vec node i off meta nil)))\n\n(defn slice-right [node shift end]\n  (if (zero? shift)\n    ;; potentially return a short node, although it would be better to\n    ;; make sure a regular leaf is always left at the right, with any\n    ;; items over the final 32 moved into tail (and then potentially\n    ;; back into the tree should the tail become too long...)\n    (let [arr     (.-arr node)\n          new-arr (make-array end)]\n      (array-copy arr 0 new-arr 0 end)\n      (->VectorNode nil new-arr))\n    (let [reg? (regular? node)\n          rngs (if-not reg? (node-ranges node))\n          i    (bit-and (bit-shift-right (dec end) shift) 0x1f)\n          i    (if reg?\n                 i\n                 (loop [j i]\n                   (if (<= end (aget rngs j))\n                     j\n                     (recur (inc j)))))\n          child-end (if reg?\n                      (let [ce (mod end (bit-shift-left 1 shift))]\n                        (if (zero? ce) (bit-shift-left 1 shift) ce))\n                      (if (pos? i)\n                        (- end (aget rngs (dec i)))\n                        end))\n          arr       (.-arr node)\n          new-child (slice-right (aget arr i) (- shift 5) child-end)\n          regular-child? (if (== shift 5)\n                           (== 32 (alength (.-arr new-child)))\n                           (regular? new-child))\n          new-arr   (make-array (if (and reg? regular-child?) 32 33))\n          new-child-rng  (if regular-child?\n                           (let [m (mod child-end (bit-shift-left 1 shift))]\n                             (if (zero? m) (bit-shift-left 1 shift) m))\n                           (if (== shift 5)\n                             (alength (.-arr new-child))\n                             (last-range new-child)))]\n      (array-copy arr 0 new-arr 0 i)\n      (aset new-arr i new-child)\n      (if-not (and reg? regular-child?)\n        (let [new-rngs (make-array 33)\n              step     (bit-shift-left 1 shift)]\n          (if reg?\n            (dotimes [j i]\n              (aset new-rngs j (* (inc j) step)))\n            (dotimes [j i]\n              (aset new-rngs j (aget rngs j))))\n          (aset new-rngs i (+ (if (pos? i) (aget new-rngs (dec i)) 0)\n                              new-child-rng))\n          (aset new-rngs 32 (inc i))\n          (aset new-arr 32 new-rngs)))\n      (->VectorNode nil new-arr))))\n\n(defn slice-left [node shift start end]\n  (if (zero? shift)\n    ;; potentially return a short node\n    (let [arr     (.-arr node)\n          new-len (- (alength arr) start)\n          new-arr (make-array new-len)]\n      (array-copy arr start new-arr 0 new-len)\n      (->VectorNode nil new-arr))\n    (let [reg? (regular? node)\n          arr  (.-arr node)\n          rngs (if-not reg? (node-ranges node))\n          i    (bit-and (bit-shift-right start shift) 0x1f)\n          i    (if reg?\n                 i\n                 (loop [j i]\n                   (if (< start (aget rngs j))\n                     j\n                     (recur (inc j)))))\n          len  (if reg?\n                 (loop [i i]\n                   (if (or (== i 32) (nil? (aget arr i)))\n                     i\n                     (recur (inc i))))\n                 (aget rngs 32))\n          child-start (if (pos? i)\n                        (- start\n                           (if reg?\n                             (* i (bit-shift-left 1 shift))\n                             (aget rngs (dec i))))\n                        start)\n          child-end   (if reg?\n                        (min (bit-shift-left 1 shift)\n                             (if (pos? i)\n                               (- end (* i (bit-shift-left 1 shift)))\n                               end))\n                        (let [capped-end (min (aget rngs i) end)]\n                          (if (pos? i)\n                            (- capped-end (aget rngs (dec i)))\n                            capped-end)))\n          new-child   (slice-left (aget arr i)\n                                  (- shift 5)\n                                  child-start\n                                  child-end)\n          new-len     (- len i)\n          new-len     (if (nil? new-child) (dec new-len) new-len)]\n      (cond\n        (zero? new-len)\n        nil\n\n        reg?\n        (let [new-arr (make-array 33)\n              rngs    (make-array 33)\n              rng0    (if (or (nil? new-child)\n                              (== shift 5)\n                              (regular? new-child))\n                        (- (bit-shift-left 1 shift)\n                           (bit-and (bit-shift-right start (- shift 5)) 0x1f))\n                        (last-range new-child))\n              step    (bit-shift-left 1 shift)]\n          (loop [j 0\n                 r rng0]\n            (when (< j new-len)\n              (aset rngs j r)\n              (recur (inc j) (+ r step))))\n          (when (> new-len 1)\n            (aset rngs (dec new-len) (- end start)))\n          (aset rngs 32 new-len)\n          (array-copy arr (if (nil? new-child) (inc i) i)\n                      new-arr 0\n                      new-len)\n          (if-not (nil? new-child)\n            (aset new-arr 0 new-child))\n          (aset new-arr 32 rngs)\n          (->VectorNode (.-edit node) new-arr))\n\n        :else\n        (let [new-arr  (make-array 33)\n              new-rngs (make-array 33)]\n          (loop [j 0 i i]\n            (when (< j new-len)\n              (aset new-rngs j (- (aget rngs i) start))\n              (recur (inc j) (inc i))))\n          (aset new-rngs 32 new-len)\n          (array-copy arr (if (nil? new-child) (inc i) i)\n                      new-arr 0\n                      new-len)\n          (if-not (nil? new-child)\n            (aset new-arr 0 new-child))\n          (aset new-arr 32 new-rngs)\n          (->VectorNode (.-edit node) new-arr))))))\n\n(declare splice-rrbts ->Transient)\n\n(deftype Vector [cnt shift root tail meta ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str* this))\n\n  IPrintWithWriter\n  (-pr-writer [this writer opts]\n    (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts this))\n\n  IWithMeta\n  (-with-meta [this meta]\n    (Vector. cnt shift root tail meta __hash))\n\n  IMeta\n  (-meta [this]\n    meta)\n\n  ISequential\n  IEquiv\n  (-equiv [this that]\n    (equiv-sequential this that))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [this]\n    (cond\n      (zero? cnt) nil\n      (zero? (-tail-offset this)) (array-seq tail)\n      :else (rrb-chunked-seq this 0 0)))\n\n  ICounted\n  (-count [_]\n    cnt)\n\n  IIndexed\n  (-nth [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (let [tail-off (- cnt (alength tail))]\n        (if (<= tail-off i)\n          (aget tail (- i tail-off))\n          (loop [i i node root shift shift]\n            (if (zero? shift)\n              (let [arr (.-arr node)]\n                (aget arr (bit-and (bit-shift-right i shift) 0x1f)))\n              (if (regular? node)\n                (let [arr (.-arr node)\n                      idx (bit-and (bit-shift-right i shift) 0x1f)]\n                  (loop [i     i\n                         node  (aget arr idx)\n                         shift (- shift 5)]\n                    (let [arr (.-arr node)\n                          idx (bit-and (bit-shift-right i shift) 0x1f)]\n                      (if (zero? shift)\n                        (aget arr idx)\n                        (recur i (aget arr idx) (- shift 5))))))\n                (let [arr  (.-arr node)\n                      rngs (node-ranges node)\n                      idx  (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                             (if (< i (aget rngs j))\n                               j\n                               (recur (inc j))))\n                      i    (if (zero? idx)\n                             i\n                             (- i (aget rngs (dec idx))))]\n                  (recur i (aget arr idx) (- shift 5))))))))\n      (vector-index-out-of-bounds i cnt)))\n\n  (-nth [this i not-found]\n    (if (and (>= i 0) (< i cnt))\n      (-nth this i)\n      not-found))\n\n  IMapEntry\n  (-key [this]\n    (-nth this 0))\n\n  (-val [this]\n    (-nth this 1))\n\n  ICollection\n  (-conj [this val]\n    (if (< (alength tail) 32)\n      (let [tail-len (alength tail)\n            new-tail (make-array (inc tail-len))]\n        (array-copy tail 0 new-tail 0 tail-len)\n        (aset new-tail tail-len val)\n        (Vector. (inc cnt) shift root new-tail meta nil))\n      (let [tail-node (->VectorNode (.-edit root) tail)\n            new-tail  (let [new-arr (make-array 1)]\n                        (aset new-arr 0 val)\n                        new-arr)]\n        (if (overflow? root shift cnt)\n          (if (regular? root)\n            (let [new-arr  (make-array 32)\n                  new-root (->VectorNode (.-edit root) new-arr)]\n              (doto new-arr\n                (aset 0 root)\n                (aset 1 (new-path tail (.-edit root) shift tail-node)))\n              (Vector. (inc cnt) (+ shift 5) new-root new-tail meta nil))\n            (let [new-arr  (make-array 33)\n                  new-rngs (make-array 33)\n                  new-root (->VectorNode (.-edit root) new-arr)\n                  root-total-range (aget (node-ranges root) 31)]\n              (doto new-arr\n                (aset 0  root)\n                (aset 1  (new-path tail (.-edit root) shift tail-node))\n                (aset 32 new-rngs))\n              (doto new-rngs\n                (aset 0  root-total-range)\n                (aset 1  (+ root-total-range 32))\n                (aset 32 2))\n              (Vector. (inc cnt) (+ shift 5) new-root new-tail meta nil)))\n          (Vector. (inc cnt) shift\n                   (push-tail shift cnt (.-edit root) root tail-node)\n                   new-tail\n                   meta\n                   nil)))))\n\n  IEmptyableCollection\n  (-empty [_]\n    (with-meta cljs.core.PersistentVector.EMPTY meta))\n\n  IStack\n  (-peek [this]\n    (when (pos? cnt)\n      (-nth this (dec cnt))))\n\n  (-pop [this]\n    (cond\n      (zero? cnt)\n      (throw (js/Error. \"Can't pop empty vector\"))\n\n      (== 1 cnt)\n      (-with-meta cljs.core.PersistentVector.EMPTY meta)\n\n      (> (alength tail) 1)\n      (let [new-tail (make-array (dec (alength tail)))]\n        (array-copy tail 0 new-tail 0 (alength new-tail))\n        (Vector. (dec cnt) shift root new-tail meta nil))\n\n      :else\n      (let [new-tail (-array-for this (- cnt 2))\n            root-cnt (-tail-offset this)\n            new-root (pop-tail shift root-cnt (.-edit root) root)]\n        (cond\n          (nil? new-root)\n          (Vector. (dec cnt) shift empty-node new-tail meta nil)\n\n          (and (> shift 5)\n               (nil? (aget (.-arr new-root) 1)))\n          (Vector. (dec cnt)\n                   (- shift 5)\n                   (aget (.-arr new-root) 0)\n                   new-tail\n                   meta\n                   nil)\n\n          :else\n          (Vector. (dec cnt) shift new-root new-tail meta nil)))))\n\n  IVector\n  (-assoc-n [this i val]\n    (cond\n      (and (<= 0 i) (< i cnt))\n      (let [tail-off (-tail-offset this)]\n        (if (>= i tail-off)\n          (let [new-tail (make-array (alength tail))\n                idx (- i tail-off)]\n            (array-copy tail 0 new-tail 0 (alength tail))\n            (aset new-tail idx val)\n            (Vector. cnt shift root new-tail meta nil))\n          (Vector. cnt shift (do-assoc shift root i val) tail meta nil)))\n\n      (== i cnt) (-conj this val)\n      :else (vector-index-out-of-bounds i cnt)))\n\n  IReversible\n  (-rseq [this]\n    (if (pos? cnt)\n      (RSeq. this (dec cnt) nil)\n      nil))\n\n  IAssociative\n  (-assoc [this k v]\n    (-assoc-n this k v))\n\n  ILookup\n  (-lookup [this k]\n    (-nth this k nil))\n\n  (-lookup [this k not-found]\n    (-nth this k not-found))\n\n  IFn\n  (-invoke [this k]\n    (-nth this k))\n\n  (-invoke [this k not-found]\n    (-nth this k not-found))\n\n  IReduce\n  (-reduce [this f]\n    (ci-reduce this f))\n\n  (-reduce [this f start]\n    (ci-reduce this f start))\n\n  IKVReduce\n  (-kv-reduce [this f init]\n    (loop [i    0\n           j    0\n           init init\n           arr  (-array-for this i)\n           lim  (dec (alength arr))\n           step (inc lim)]\n      (let [init (f init (+ i j) (aget arr j))]\n        (if (reduced? init)\n          @init\n          (if (< j lim)\n            (recur i (inc j) init arr lim step)\n            (let [i (+ i step)]\n              (if (< i cnt)\n                (let [arr (-array-for this i)\n                      len (alength arr)\n                      lim (dec len)]\n                  (recur i 0 init arr lim len))\n                init)))))))\n\n  IComparable\n  (-compare [this that]\n    (compare-indexed this that))\n\n  IEditableCollection\n  (-as-transient [this]\n    (->Transient cnt\n                 shift\n                 (editable-root root)\n                 (editable-tail tail)\n                 (alength tail)))\n\n  PSliceableVector\n  (-slicev [this start end]\n    (let [new-cnt (- end start)]\n      (cond\n        (or (neg? start) (> end cnt))\n        (throw (js/Error. \"vector index out of bounds\"))\n\n        (== start end)\n        ;; NB. preserves metadata\n        (empty this)\n\n        (> start end)\n        (throw (js/Error. \"start index greater than end index\"))\n\n        :else\n        (let [tail-off (-tail-offset this)]\n          (if (>= start tail-off)\n            (let [new-tail (make-array new-cnt)]\n              (array-copy tail (- start tail-off)\n                          new-tail 0\n                          new-cnt)\n              (Vector. new-cnt 5 empty-node new-tail meta nil))\n            (let [tail-cut? (> end tail-off)\n                  new-root  (if tail-cut?\n                              root\n                              (slice-right root shift end))\n                  new-root  (if (zero? start)\n                              new-root\n                              (slice-left new-root shift start\n                                          (min end tail-off)))\n                  new-tail  (if tail-cut?\n                              (let [new-len  (- end tail-off)\n                                    new-tail (make-array new-len)]\n                                (array-copy tail 0 new-tail 0 new-len)\n                                new-tail)\n                              (-array-for (Vector. new-cnt shift new-root\n                                                   (array) meta nil)\n                                          (dec new-cnt)))\n                  new-root  (if tail-cut?\n                              new-root\n                              (pop-tail shift new-cnt (.-edit new-root)\n                                        new-root))]\n              (if (nil? new-root)\n                (Vector. new-cnt 5 empty-node new-tail meta nil)\n                (loop [r new-root\n                       s shift]\n                  (if (and (> s 5)\n                           (nil? (aget (.-arr r) 1)))\n                    (recur (aget (.-arr r) 0) (- s 5))\n                    (Vector. new-cnt s r new-tail meta nil))))))))))\n\n  PSpliceableVector\n  (-splicev [this that]\n    (splice-rrbts this (-as-rrbt that)))\n\n  IVecImpl\n  (-tail-offset [this]\n    (- cnt (alength tail)))\n\n  (-array-for [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (if (>= i (-tail-offset this))\n        tail\n        (loop [i i node root shift shift]\n          (if (zero? shift)\n            (.-arr node)\n            (if (regular? node)\n              (loop [node  (aget (.-arr node)\n                                 (bit-and (bit-shift-right i shift) 0x1f))\n                     shift (- shift 5)]\n                (if (zero? shift)\n                  (.-arr node)\n                  (recur (aget (.-arr node)\n                               (bit-and (bit-shift-right i shift) 0x1f))\n                         (- shift 5))))\n              (let [rngs (node-ranges node)\n                    j    (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                           (if (< i (aget rngs j))\n                             j\n                             (recur (inc j))))\n                    i    (if (pos? j)\n                           (- i (aget rngs (dec j)))\n                           i)]\n                (recur i\n                       (aget (.-arr node) j)\n                       (- shift 5)))))))\n      (vector-index-out-of-bounds i cnt)))\n\n  AsRRBT\n  (-as-rrbt [this]\n    this))\n\n(extend-protocol AsRRBT\n  cljs.core.PersistentVector\n  (-as-rrbt [this]\n    (Vector. (count this) (.-shift this) (.-root this) (.-tail this)\n             (meta this) nil))\n\n  Subvec\n  (-as-rrbt [this]\n    (let [v     (.-v this)\n          start (.-start this)\n          end   (.-end this)]\n      (-slicev (-as-rrbt v) start end))))\n\n(defn shift-from-to [node from to]\n  (cond\n    (== from to)\n    node\n\n    (regular? node)\n    (recur (->VectorNode (.-edit node) (doto (make-array 32) (aset 0 node)))\n           (+ 5 from)\n           to)\n\n    :else\n    (recur (->VectorNode (.-edit node)\n                         (doto (make-array 33)\n                           (aset 0 node)\n                           (aset 32\n                                 (doto (make-array 33)\n                                   (aset 0  (last-range node))\n                                   (aset 32 1)))))\n           (+ 5 from)\n           to)))\n\n(defn slot-count [node shift]\n  (let [arr (.-arr node)]\n    (if (zero? shift)\n      (alength arr)\n      (if (regular? node)\n        (index-of-nil arr)\n        (let [rngs (node-ranges node)]\n          (aget rngs 32))))))\n\n(defn subtree-branch-count [node shift]\n  ;; NB. positive shifts only\n  (let [arr (.-arr node)\n        cs  (- shift 5)]\n    (if (regular? node)\n      (loop [i 0 sbc 0]\n        (if (== i 32)\n          sbc\n          (if-let [child (aget arr i)]\n            (recur (inc i) (+ sbc (slot-count child cs)))\n            sbc)))\n      (let [lim (aget (node-ranges node) 32)]\n        (loop [i 0 sbc 0]\n          (if (== i lim)\n            sbc\n            (let [child (aget arr i)]\n              (recur (inc i) (+ sbc (slot-count child cs))))))))))\n\n(defn leaf-seq [arr]\n  (mapcat #(.-arr %) (take (index-of-nil arr) arr)))\n\n(defn rebalance-leaves\n  [n1 cnt1 n2 cnt2 transferred-leaves]\n  (let [slc1 (slot-count n1 5)\n        slc2 (slot-count n2 5)\n        a    (+ slc1 slc2)\n        sbc1 (subtree-branch-count n1 5)\n        sbc2 (subtree-branch-count n2 5)\n        p    (+ sbc1 sbc2)\n        e    (- a (inc (quot (dec p) 32)))]\n    (cond\n      (<= e max-extra-search-steps)\n      (array n1 n2)\n\n      (<= (+ sbc1 sbc2) 1024)\n      (let [reg?    (zero? (mod p 32))\n            new-arr (make-array (if reg? 32 33))\n            new-n1  (->VectorNode nil new-arr)]\n        (loop [i  0\n               bs (partition-all 32\n                                 (concat (leaf-seq (.-arr n1))\n                                         (leaf-seq (.-arr n2))))]\n          (when-first [block bs]\n            (let [a (make-array (count block))]\n              (loop [i 0 xs (seq block)]\n                (when xs\n                  (aset a i (first xs))\n                  (recur (inc i) (next xs))))\n              (aset new-arr i (->VectorNode nil a))\n              (recur (inc i) (next bs)))))\n        (if-not reg?\n          (aset new-arr 32 (regular-ranges 5 p)))\n        (set! (.-val transferred-leaves) sbc2)\n        (array new-n1 nil))\n\n      :else\n      (let [reg?     (zero? (mod p 32))\n            new-arr1 (make-array 32)\n            new-arr2 (make-array (if reg? 32 33))\n            new-n1   (->VectorNode nil new-arr1)\n            new-n2   (->VectorNode nil new-arr2)]\n        (loop [i  0\n               bs (partition-all 32\n                                 (concat (leaf-seq (.-arr n1))\n                                         (leaf-seq (.-arr n2))))]\n          (when-first [block bs]\n            (let [a (make-array (count block))]\n              (loop [i 0 xs (seq block)]\n                (when xs\n                  (aset a i (first xs))\n                  (recur (inc i) (next xs))))\n              (if (< i 32)\n                (aset new-arr1 i (->VectorNode nil a))\n                (aset new-arr2 (- i 32) (->VectorNode nil a)))\n              (recur (inc i) (next bs)))))\n        (if-not reg?\n          (aset new-arr2 32 (regular-ranges 5 (- p 1024))))\n        (set! (.-val transferred-leaves) (- 1024 sbc1))\n        (array new-n1 new-n2)))))\n\n(defn child-seq [node shift cnt]\n  (let [arr  (.-arr node)\n        rngs (if (regular? node)\n               (regular-ranges shift cnt)\n               (node-ranges node))\n        cs   (if rngs (aget rngs 32) (index-of-nil arr))\n        cseq (fn cseq [c r]\n               (let [arr  (.-arr c)\n                     rngs (if (regular? c)\n                            (regular-ranges (- shift 5) r)\n                            (node-ranges c))\n                     gcs  (if rngs (aget rngs 32) (index-of-nil arr))]\n                 (map list\n                      (take gcs arr)\n                      (take gcs (map - rngs (cons 0 rngs))))))]\n    (mapcat cseq (take cs arr) (take cs (map - rngs (cons 0 rngs))))))\n\n(defn rebalance\n  [shift n1 cnt1 n2 cnt2 transferred-leaves]\n  (if (nil? n2)\n    (array n1 nil)\n    (let [slc1 (slot-count n1 shift)\n          slc2 (slot-count n2 shift)\n          a    (+ slc1 slc2)\n          sbc1 (subtree-branch-count n1 shift)\n          sbc2 (subtree-branch-count n2 shift)\n          p    (+ sbc1 sbc2)\n          e    (- a (inc (quot (dec p) 32)))]\n      (cond\n        (<= e max-extra-search-steps)\n        (array n1 n2)\n\n        (<= (+ sbc1 sbc2) 1024)\n        (let [new-arr  (make-array 33)\n              new-rngs (make-array 33)\n              new-n1   (->VectorNode nil new-arr)]\n          (loop [i  0\n                 bs (partition-all 32\n                                   (concat (child-seq n1 shift cnt1)\n                                           (child-seq n2 shift cnt2)))]\n            (when-first [block bs]\n              (let [a (make-array 33)\n                    r (make-array 33)]\n                (aset a 32 r)\n                (aset r 32 (count block))\n                (loop [i 0 o 0 gcs (seq block)]\n                  (when-first [[gc gcr] gcs]\n                    (aset a i gc)\n                    (aset r i (+ o gcr))\n                    (recur (inc i) (+ o gcr) (next gcs))))\n                (aset new-arr i (->VectorNode nil a))\n                (aset new-rngs i\n                      (+ (aget r (dec (aget r 32)))\n                         (if (pos? i) (aget new-rngs (dec i)) 0)))\n                (aset new-rngs 32 (inc i))\n                (recur (inc i) (next bs)))))\n          (aset new-arr 32 new-rngs)\n          (set! (.-val transferred-leaves) cnt2)\n          (array new-n1 nil))\n\n        :else\n        (let [new-arr1  (make-array 33)\n              new-arr2  (make-array 33)\n              new-rngs1 (make-array 33)\n              new-rngs2 (make-array 33)\n              new-n1    (->VectorNode nil new-arr1)\n              new-n2    (->VectorNode nil new-arr2)]\n          (loop [i  0\n                 bs (partition-all 32\n                                   (concat (child-seq n1 shift cnt1)\n                                           (child-seq n2 shift cnt2)))]\n            (when-first [block bs]\n              (let [a (make-array 33)\n                    r (make-array 33)]\n                (aset a 32 r)\n                (aset r 32 (count block))\n                (loop [i 0 o 0 gcs (seq block)]\n                  (when-first [[gc gcr] gcs]\n                    (aset a i gc)\n                    (aset r i (+ o gcr))\n                    (recur (inc i) (+ o gcr) (next gcs))))\n                (if (and (< i 32) (> (+ (* i 32) (count block)) sbc1))\n                  (let [tbs (- (+ (* i 32) (count block)) sbc1)\n                        li  (dec (aget r 32))\n                        d   (if (>= tbs 32)\n                              (aget r li)\n                              (- (aget r li) (aget r (- li tbs))))]\n                    (set! (.-val transferred-leaves)\n                          (+ (.-val transferred-leaves) d))))\n                (let [new-arr  (if (< i 32) new-arr1 new-arr2)\n                      new-rngs (if (< i 32) new-rngs1 new-rngs2)\n                      i        (mod i 32)]\n                  (aset new-arr i (->VectorNode nil a))\n                  (aset new-rngs i\n                        (+ (aget r (dec (aget r 32)))\n                           (if (pos? i) (aget new-rngs (dec i)) 0)))\n                  (aset new-rngs 32 (inc i)))\n                (recur (inc i) (next bs)))))\n          (aset new-arr1 32 new-rngs1)\n          (aset new-arr2 32 new-rngs2)\n          (array new-n1 new-n2))))))\n\n(defn zippath\n  [shift n1 cnt1 n2 cnt2 transferred-leaves]\n  (if (== shift 5)\n    (rebalance-leaves n1 cnt1 n2 cnt2 transferred-leaves)\n    (let [c1 (last-child n1)\n          c2 (first-child n2)\n          ccnt1 (if (regular? n1)\n                  (let [m (mod cnt1 (bit-shift-left 1 shift))]\n                    (if (zero? m) (bit-shift-left 1 shift) m))\n                  (let [rngs (node-ranges n1)\n                        i    (dec (aget rngs 32))]\n                    (if (zero? i)\n                      (aget rngs 0)\n                      (- (aget rngs i) (aget rngs (dec i))))))\n          ccnt2 (if (regular? n2)\n                  (let [m (mod cnt2 (bit-shift-left 1 shift))]\n                    (if (zero? m) (bit-shift-left 1 shift) m))\n                  (aget (node-ranges n2) 0))\n          next-transferred-leaves (Box. 0)\n          [new-c1 new-c2] (zippath (- shift 5) c1 ccnt1 c2 ccnt2\n                                   next-transferred-leaves)\n          d (.-val next-transferred-leaves)]\n      (set! (.-val transferred-leaves) (+ (.-val transferred-leaves) d))\n      (rebalance shift\n                 (if (identical? c1 new-c1)\n                   n1\n                   (replace-rightmost-child shift n1 new-c1 d))\n                 (+ cnt1 d)\n                 (if new-c2\n                   (if (identical? c2 new-c2)\n                     n2\n                     (replace-leftmost-child shift n2 cnt2 new-c2 d))\n                   (remove-leftmost-child shift n2))\n                 (- cnt2 d)\n                 transferred-leaves))))\n\n(defn squash-nodes [shift n1 cnt1 n2 cnt2]\n  (let [arr1  (.-arr n1)\n        arr2  (.-arr n2)\n        li1   (index-of-nil arr1)\n        li2   (index-of-nil arr2)\n        slots (concat (take li1 arr1) (take li2 arr2))]\n    (if (> (count slots) 32)\n      (array n1 n2)\n      (let [new-rngs (make-array 33)\n            new-arr  (make-array 33)\n            rngs1    (take li1 (if (regular? n1)\n                                 (regular-ranges shift cnt1)\n                                 (node-ranges n1)))\n            rngs2    (take li2 (if (regular? n2)\n                                 (regular-ranges shift cnt2)\n                                 (node-ranges n2)))\n            rngs2    (let [r (last rngs1)]\n                       (map #(+ % r) rngs2))\n            rngs     (concat rngs1 rngs2)]\n        (aset new-arr 32 new-rngs)\n        (loop [i 0 cs (seq slots)]\n          (when cs\n            (aset new-arr i (first cs))\n            (recur (inc i) (next cs))))\n        (loop [i 0 rngs (seq rngs)]\n          (if rngs\n            (do (aset new-rngs i (first rngs))\n                (recur (inc i) (next rngs)))\n            (aset new-rngs 32 i)))\n        (array (->VectorNode nil new-arr) nil)))))\n\n(def peephole-optimization-config (atom {:debug-fn nil}))\n(def peephole-optimization-count (atom 0))\n\n;; TBD: Transducer versions of child-nodes and bounded-grandchildren\n;; are included here for when we are willing to rely upon Clojure\n;; 1.7.0 as the minimum version supported by the core.rrb-vector\n;; library.  They are faster.\n\n#_(defn child-nodes [node]\n  (into [] (comp (take-while (complement nil?))\n                 (take 32))\n        (.-arr node)))\n\n(defn child-nodes [node]\n  (->> (.-arr node)\n       (take-while (complement nil?))\n       (take 32)))\n\n;; (take 33) is just a technique to avoid generating more\n;; grandchildren than necessary.  If there are at least 33, we do not\n;; care how many there are.\n#_(defn bounded-grandchildren [children]\n  (into [] (comp (map child-nodes)\n                 cat\n                 (take 33))\n        children))\n\n(defn bounded-grandchildren [children]\n  (->> children\n       (mapcat child-nodes)\n       (take 33)))\n\n;; TBD: Do functions like last-non-nil-idx and\n;; count-vector-elements-beneath already exist elsewhere in this\n;; library?  It seems like they might.\n\n;; A regular tree node is guaranteed to have only 32-way branching at\n;; all nodes, except perhaps along the right spine, where it can be\n;; partial.  From a regular tree node down, all leaf arrays\n;; (containing vector elements directly) are restricted to contain a\n;; full 32 vector elements.  This code relies on these invariants to\n;; quickly calculate the number of vector elements beneath a regular\n;; node in O(log N) time.\n\n(defn last-non-nil-idx [arr]\n  (loop [i (dec (alength arr))]\n    (if (neg? i)\n      i\n      (if (nil? (aget arr i))\n        (recur (dec i))\n        i))))\n\n(defn count-vector-elements-beneath [node shift]\n  (if (regular? node)\n    (loop [node node\n           shift shift\n           acc 0]\n      (if (zero? shift)\n        (if (nil? node)\n          acc\n          ;; The +32 is for the regular leaf node reached at shift 0\n          (+ acc 32))\n        (let [arr (.-arr node)\n              max-child-idx (last-non-nil-idx arr)\n              num-elems-in-full-child (bit-shift-left 1 shift)]\n          (if (< max-child-idx 0)\n            acc\n            (recur (aget arr max-child-idx)\n                   (- shift 5)\n                   (+ acc (* max-child-idx num-elems-in-full-child)))))))\n    ;; irregular case\n    (let [rngs (node-ranges node)]\n      (aget rngs (dec (aget rngs 32))))))\n\n(defn peephole-optimize-root [v]\n  (let [config @peephole-optimization-config]\n    (if (<= (.-shift v) 10)\n      ;; Tree depth cannot be reduced if shift <= 5.\n      ;; TBD: If shift=10, the grandchildren nodes need to be handled\n      ;; by an am array manager for primitive vectors, which I haven't\n      ;; written code for yet below, but so far this peephole\n      ;; optimizer seems to be working sufficiently well without\n      ;; handling that case.\n      v\n      (let [root (.-root v)\n            children (child-nodes root)\n            grandchildren (bounded-grandchildren children)\n            num-granchildren-bounded (count grandchildren)\n            many-grandchildren? (> num-granchildren-bounded 32)]\n        (if many-grandchildren?\n          ;; If it is possible to reduce tree depth, it requires going\n          ;; deeper than just to the grandchildren, which is beyond\n          ;; what this peephole optimizer is intended to do.\n          v\n          ;; Create a new root node that points directly at the\n          ;; grandchildren, since there are few enough of them.\n          (let [new-arr  (make-array 33)\n                new-rngs (make-array 33)\n                new-root (->VectorNode (.-edit root) new-arr)\n                shift    (.-shift v)\n                grandchild-shift (- shift (* 2 5))]\n            (swap! peephole-optimization-count inc)\n            (loop [idx 0\n                   remaining-gc grandchildren\n                   elem-sum 0]\n              (if-let [remaining-gc (seq remaining-gc)]\n                (let [grandchild (first remaining-gc)\n                      num-elems-this-grandchild (count-vector-elements-beneath\n                                                 grandchild grandchild-shift)\n                      next-elem-sum (+ elem-sum num-elems-this-grandchild)]\n                  (aset new-arr idx grandchild)\n                  (aset new-rngs idx next-elem-sum)\n                  (recur (inc idx) (rest remaining-gc) next-elem-sum))))\n            (aset new-rngs 32 num-granchildren-bounded)\n            (aset new-arr 32 new-rngs)\n            (let [new-v (Vector. (.-cnt v) (- shift 5)\n                                 new-root (.-tail v) (.-meta v) nil)]\n              (when (:debug-fn config)\n                ((:debug-fn config) v new-v))\n              new-v)))))))\n\n;; TBD: I do not know if this implementation actually supports this\n;; many elements in one vector.  What is the limit?  I picked this\n;; number simply to match what I believe is the upper limit for the\n;; Clojure implementation.\n(def max-vector-elements 2147483647)\n\n;; Larger shift values than 64 definitely break assumptions all over\n;; the RRB vector implementation, e.g. (bit-shift-right 255 65)\n;; returns the same result as (bit-shift-right 255 1), I believe\n;; because the shift amount argument is effectively modulo'd by 64.\n;; Larger shift values than 30 are unlikely to make sense, given that\n;; the maximum number of vector elements supported is somewhere near\n;; 2^31-1.\n\n(defn shift-too-large? [v]\n  (> (.-shift v) 30))\n\n;; The maximum number of vector elements in a tree, not counting any\n;; elements in the tail, with a given shift value is:\n;;\n;; (bit-shift-left 1 (+ shift 5))\n;;\n;; It is perfectly normal to have vectors with a root tree node with\n;; only 1 non-nil child, so at a fraction 1/32 of maximum capacity.  I\n;; do not know the exact minimum fraction that RRB vectors as\n;; implemented here should allow, but I suspect it is well over\n;; 1/1024.\n\n(defn poor-branching? [v]\n  (let [tail-off (-tail-offset v)]\n    (if (zero? tail-off)\n      false\n      (let [shift-amount (- (.-shift v) 5)\n            max-capacity-divided-by-1024 (bit-shift-left 1 shift-amount)]\n        (< tail-off max-capacity-divided-by-1024)))))\n\n;; Note 3:\n\n;; Consider measuring several ways in ClojureScript to create a\n;; regular persistent vector from another one, to see which is\n;; fastest, and use it here.\n\n;; TBD: Is there any promise about what metadata catvec returns?\n;; Always the same as on the first argument?\n\n(def fallback-config (atom {:debug-fn nil}))\n(def fallback-to-slow-splice-count1 (atom 0))\n(def fallback-to-slow-splice-count2 (atom 0))\n\n(defn fallback-to-slow-splice-if-needed [v1 v2 splice-result]\n  (let [config @fallback-config]\n    (if (or (shift-too-large? splice-result)\n            (poor-branching? splice-result))\n      (do\n        (dbg (str \"splice-rrbts result had shift \" (.-shift splice-result)\n                  \" and \" (-tail-offset splice-result) \" elements not counting\"\n                  \" the tail. Falling back to slower method of concatenation.\"))\n        (if (poor-branching? v1)\n          ;; The v1 we started with was not good, either.\n          (do\n            (swap! fallback-to-slow-splice-count1 inc)\n            (dbg (str \"splice-rrbts first arg had shift \" (.-shift v1)\n                      \" and \" (-tail-offset v1) \" elements not counting\"\n                      \" the tail.  Building the result from scratch.\"))\n            ;: See Note 3\n            (let [new-splice-result (-> (empty v1) (into v1) (into v2))]\n              (when (:debug-fn config)\n                ((:debug-fn config) splice-result new-splice-result))\n              new-splice-result))\n          ;; Assume that v1 is balanced enough that we can use into to\n          ;; add all elements of v2 to it, without problems.  TBD:\n          ;; That assumption might be incorrect.  Consider checking\n          ;; the result of this, too, and fall back again to the true\n          ;; case above?\n          (let [new-splice-result (into v1 v2)]\n            (swap! fallback-to-slow-splice-count2 inc)\n            (when (:debug-fn config)\n              ((:debug-fn config) splice-result new-splice-result))\n            new-splice-result)))\n      ;; else the fast result is good\n      splice-result)))\n\n(defn splice-rrbts-main [v1 v2]\n  (cond\n    (zero? (count v1)) v2\n    (> (+ (count v1) (count v2)) max-vector-elements)\n    (let [c1 (count v1), c2 (count v2)]\n      (throw (js/Error.\n              (str \"Attempted to concatenate two vectors whose total\"\n                   \" number of elements is \" (+ c1 c2) \", which is\"\n                   \" larger than the maximum number of elements \"\n                   max-vector-elements \" supported in a vector \"))))\n    (< (count v2) rrbt-concat-threshold) (into v1 v2)\n    :else\n    (let [s1 (.-shift v1)\n          s2 (.-shift v2)\n          r1 (.-root v1)\n          o? (overflow? r1 s1 (+ (count v1) (- 32 (alength (.-tail v1)))))\n          r1 (if o?\n               (let [tail      (.-tail v1)\n                     tail-node (->VectorNode nil tail)\n                     reg?      (and (regular? r1) (== (alength tail) 32))\n                     arr       (make-array (if reg? 32 33))]\n                 (aset arr 0 r1)\n                 (aset arr 1 (new-path* s1 tail-node))\n                 (if-not reg?\n                   (let [rngs (make-array 33)]\n                     (aset rngs 32 2)\n                     (aset rngs 0 (- (count v1) (alength tail)))\n                     (aset rngs 1 (count v1))\n                     (aset arr 32 rngs)))\n                 (->VectorNode nil arr))\n               (fold-tail r1 s1\n                          (-tail-offset v1)\n                          (.-tail v1)))\n          s1 (if o? (+ s1 5) s1)\n          r2 (.-root v2)\n          s  (max s1 s2)\n          r1 (shift-from-to r1 s1 s)\n          r2 (shift-from-to r2 s2 s)\n          transferred-leaves (Box. 0)\n          [n1 n2] (zippath s\n                           r1 (count v1)\n                           r2 (- (count v2) (alength (.-tail v2)))\n                           transferred-leaves)\n          d (.-val transferred-leaves)\n          ncnt1   (+ (count v1) d)\n          ncnt2   (- (count v2) (alength (.-tail v2)) d)\n          [n1 n2] (if (identical? n2 r2)\n                    (squash-nodes s n1 ncnt1 n2 ncnt2)\n                    (array n1 n2))\n          ncnt1   (if n2\n                    ncnt1\n                    (+ ncnt1 ncnt2))\n          ncnt2   (if n2\n                    ncnt2\n                    0)]\n      (if n2\n        (let [arr      (make-array 33)\n              new-root (->VectorNode nil arr)]\n          (aset arr 0 n1)\n          (aset arr 1 n2)\n          (aset arr 32 (doto (make-array 33)\n                         (aset 0 ncnt1)\n                         (aset 1 (+ ncnt1 ncnt2))\n                         (aset 32 2)))\n          (Vector. (+ (count v1) (count v2)) (+ s 5) new-root (.-tail v2)\n                   nil nil))\n        (loop [r n1\n               s s]\n          (if (and (> s 5)\n                   (nil? (aget (.-arr r) 1)))\n            (recur (aget (.-arr r) 0) (- s 5))\n            (Vector. (+ (count v1) (count v2)) s r (.-tail v2)\n                     nil nil)))))))\n\n(defn splice-rrbts [v1 v2]\n  (let [r1 (splice-rrbts-main v1 v2)\n        r2 (peephole-optimize-root r1)]\n    (fallback-to-slow-splice-if-needed v1 v2 r2)))\n\n(deftype Transient [^:mutable cnt\n                    ^:mutable shift\n                    ^:mutable root\n                    ^:mutable tail\n                    ^:mutable tidx]\n  ITransientCollection\n  (-conj! [this o]\n    (if ^boolean (.-edit root)\n      (if (< tidx 32)\n        (do (aset tail tidx o)\n            (set! cnt  (inc cnt))\n            (set! tidx (inc tidx))\n            this)\n        (let [tail-node (->VectorNode (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (set! tidx 1)\n          (if (overflow? root shift cnt)\n            (if (regular? root)\n              (let [new-arr (make-array 32)]\n                (doto new-arr\n                  (aset 0 root)\n                  (aset 1 (new-path tail (.-edit root) shift tail-node)))\n                (set! root  (->VectorNode (.-edit root) new-arr))\n                (set! shift (+ shift 5))\n                (set! cnt   (inc cnt))\n                this)\n              (let [new-arr  (make-array 33)\n                    new-rngs (make-array 33)\n                    new-root (->VectorNode (.-edit root) new-arr)\n                    root-total-range (aget (node-ranges root) 31)]\n                (doto new-arr\n                  (aset 0  root)\n                  (aset 1  (new-path tail (.-edit root) shift tail-node))\n                  (aset 32 new-rngs))\n                (doto new-rngs\n                  (aset 0  root-total-range)\n                  (aset 1  (+ root-total-range 32))\n                  (aset 32 2))\n                (set! root  new-root)\n                (set! shift (+ shift 5))\n                (set! cnt   (inc cnt))\n                this))\n            (let [new-root (push-tail! shift cnt (.-edit root) root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              this))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [this]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [trimmed-tail (make-array tidx)]\n            (array-copy tail 0 trimmed-tail 0 tidx)\n            (Vector. cnt shift root trimmed-tail nil nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [this key val]\n    (-assoc-n! this key val))\n\n  ITransientVector\n  (-assoc-n! [this i val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 i) (< i cnt))\n        (let [tail-off (- cnt tidx)]\n          (if (<= tail-off i)\n            (aset tail (- i tail-off) val)\n            (set! root (do-assoc! shift (.-edit root) root i val)))\n          this)\n\n        (== i cnt) (-conj! this val)\n\n        :else (vector-index-out-of-bounds i cnt))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [this]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt)\n        (throw (js/Error. \"Can't pop empty vector\"))\n\n        (== 1 cnt)\n        (do (set! cnt  0)\n            (set! tidx 0)\n            (aset tail 0 nil)\n            this)\n\n        (> tidx 1)\n        (do (set! cnt  (dec cnt))\n            (set! tidx (dec tidx))\n            (aset tail tidx nil)\n            this)\n\n        :else\n        (let [new-tail-base (-array-for this (- cnt 2))\n              new-tail      (editable-tail new-tail-base)\n              new-tidx      (alength new-tail-base)\n              new-root      (pop-tail! shift cnt (.-edit root) root)]\n          (cond\n            (nil? new-root)\n            (do (set! cnt  (dec cnt))\n                (set! root (ensure-editable (.-edit root) empty-node))\n                (set! tail new-tail)\n                (set! tidx new-tidx)\n                this)\n\n            (and (> shift 5)\n                 (nil? (aget (.-arr new-root) 1)))\n            (do (set! cnt   (dec cnt))\n                (set! shift (- shift 5))\n                (set! root  (ensure-editable (.-edit root)\n                                             (aget (.-arr new-root) 0)))\n                (set! tail  new-tail)\n                (set! tidx  new-tidx)\n                this)\n\n            :else\n            (do (set! cnt  (dec cnt))\n                (set! root new-root)\n                (set! tail new-tail)\n                (set! tidx new-tidx)\n                this))))\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ICounted\n  (-count [this]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IVecImpl\n  (-tail-offset [this]\n    (- cnt tidx))\n\n  (-array-for [this i]\n    (if (and (<= 0 i) (< i cnt))\n      (if (>= i (-tail-offset this))\n        tail\n        (loop [i i node root shift shift]\n          (if (zero? shift)\n            (.-arr node)\n            (if (regular? node)\n              (loop [node  (aget (.-arr node)\n                                 (bit-and (bit-shift-right i shift) 0x1f))\n                     shift (- shift 5)]\n                (if (zero? shift)\n                  (.-arr node)\n                  (recur (aget (.-arr node)\n                               (bit-and (bit-shift-right i shift) 0x1f))\n                         (- shift 5))))\n              (let [rngs (node-ranges node)\n                    j    (loop [j (bit-and (bit-shift-right i shift) 0x1f)]\n                           (if (< i (aget rngs j))\n                             j\n                             (recur (inc j))))\n                    i    (if (pos? j)\n                           (- i (aget rngs (dec j)))\n                           i)]\n                (recur i\n                       (aget (.-arr node) j)\n                       (- shift 5)))))))\n      (vector-index-out-of-bounds i cnt))))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings",";AAiBA,AAAA,AAAaA;AACb,AAAA,AAAaC;AAEb,AAAA;AAAA;;;AAAA,AAAaU;;AAAb,AAAAT,AAAA,AACiBU;AADjB,AAAA,AAAAT,AAAA,AAAA,AAAA,AAAA,AACiBS,AAAAA;AADjBR,AAAA,AAAAC,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACiBQ,AAAAA;;AADjB,AAAAL,AAAA,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAE,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACiBK,AAAAA;;AADjB,AAAA,AAAAJ,AAAA,AACiBI;;;;AADjB,AAAA,AAAA,AACGP,AAAcO;AADjB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACiBA,AAAAA;AADjB,AACiBA,AAAAA;;AADjB,AAAAV,AACiBU;;;;AADjB,AAAAH,AAAA,AAEeG,AAAEC;AAFjB,AAAA,AAAAV,AAAA,AAAA,AAAA,AAAA,AAEeS,AAAAA;AAFfR,AAAA,AAAAM,AAAA,AAAAJ,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAEeQ,AAAAA,AAAEC,AAAAA;;AAFjB,AAAAN,AAAA,AAAAG,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAEeK,AAAAA,AAAEC,AAAAA;;AAFjB,AAAA,AAAAL,AAAA,AAEeI;;;;AAFf,AAAA,AAAA,AAEGF,AAAYE,AAAEC;AAFjB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAEeD,AAAAA;AAFf,AAEeA,AAAAA,AAAEC;;AAFjB,AAAAJ,AAEeG,AAAEC;;;;AAFjB,AAIA,AAAA;AAAA;;;AAAA,AAAaG;;AAAb,AAAAF,AAAA,AACaF;AADb,AAAA,AAAAT,AAAA,AAAA,AAAA,AAAA,AACaS,AAAAA;AADbR,AAAA,AAAAW,AAAA,AAAAT,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACaQ,AAAAA;;AADb,AAAAL,AAAA,AAAAQ,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAR,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACaK,AAAAA;;AADb,AAAA,AAAAJ,AAAA,AACaI;;;;AADb,AAAA,AAAA,AACGG,AAAUH;AADb,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACaA,AAAAA;AADb,AACaA,AAAAA;;AADb,AAAAE,AACaF;;;;AADb,AAMA,AAAA,AAEA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASS;;AAAT,AAAA,AAAA,AAEaO;AAFb,AAGI,AAACC,AAAQD;;;AAHb,AAAA,AAAA,AAAA,AAASP,AAMMS,AAAKC,AAAOC;;AAN3B,AAAA,AAAA,AAMeF;AANf,AAOI,AAAA,AAAA,AAAA,AAACG,AAAqBF,AAAOG,AAAsBF,AAAKF;;;AAP5D,AAAA,AAAA,AAAA,AAAST,AAcCO;;AAdV,AAAA,AAAA,AAcUA;AAdV,AAcgBF;;;AAdhB,AAAA,AAAA,AAAA,AAASL,AAqCCO;;AArCV,AAAA,AAAA,AAqCUA;AArCV,AAsCI,AAAI,AAAG,AAAA,AAAKH,AAAK,AAASD;AACxB,AAAMe,AAAE,AAAAK,AAAiBrB;AAAjBsB,AAAqBrB;AAArBsB,AAA0BjC;AAA1BkC,AAA4B,AAAA,AAAKtB;AAAjC,AAAA,AAAAmB,AAAAC,AAAAC,AAAAC,AAAAH,AAAAC,AAAAC,AAAAC,AAACX,AAAAA,AAAAA;;AAAT,AACE,AAAI,AAAA,AAAMG;AAAV;;AAEEA;;;AACJ,AAAeX;;;;AA3CrB,AAAA,AAAA,AAAA,AAASP,AA2ECO;;AA3EV,AAAA,AAAA,AA2EUA;AA3EV,AA2EgB,AAAAiC,AAAqClC;AAArC,AAAA,AAAA,AAAA,AAAAkC,AAAA;AAAAA;;AAAA,AAAAA,AAAA,AAAcjC,AAAKkC;AAAnB,AAAA,AAAAD,AAAqClC;;AAArCkC;;;;AA3EhB,AAAA,AAAA,AAAA,AAASxC,AAqBEO,AAAKS;;AArBhB,AAAA,AAAA,AAqBWT;AArBX,AAqBuB,AAACU,AAAiBV,AAAKS;;;AArB9C,AAAA,AAAA,AAAA,AAAShB,AAkDEO;;AAlDX,AAAA,AAAA,AAkDWA;AAlDX,AAmDI,AAACsB,AAAU,AAAAC,AAAqBzB;;;AAnDpC,AAAA,AAAA,AAAA,AAASL,AA8EGO,AAAKmC;;AA9EjB,AAAA,AAAA,AA8EYnC;AA9EZ,AA+EI,AAACoC,AAAU,AAACC,AAAiB1C,AAAI,AAAGV,AAAEY,AAAK,AAACyC,AAAM3C,AAAMwC;;;AA/E5D,AAAA,AAAA,AAAA,AAAS1C,AAiFGO,AAAKmC,AAAEI;;AAjFnB,AAAA,AAAA,AAiFYvC;AAjFZ,AAkFI,AAACoC,AAAU,AAACC,AAAiB1C,AAAI,AAAGV,AAAEY,AAAK,AAACyC,AAAM3C,AAAMwC,AAAEI;;;AAlF9D,AAAA,AAAA,AAAA,AAAS9C,AAyBEO;;AAzBX,AAAA,AAAA,AAyBWA;AAzBX,AA0BI,AAAMJ,AAAKC;;;AA1Bf,AAAA,AAAA,AAAA,AAASJ,AA4BCO;;AA5BV,AAAA,AAAA,AA4BUA;AA5BV,AA6BI,AAAI,AAAG,AAAA,AAAKH,AAAK,AAASD;AACxB,AAAMe,AAAE,AAAAC,AAAiBjB;AAAjBkB,AAAqBjB;AAArBkB,AAA0B7B;AAA1B8B,AAA4B,AAAA,AAAKlB;AAAjC,AAAA,AAAAe,AAAAC,AAAAC,AAAAC,AAAAH,AAAAC,AAAAC,AAAAC,AAACP,AAAAA,AAAAA;;AAAT,AACE,AAAI,AAAA,AAAMG;AAAV;;AAEEA;;;AACJ,AAAeX;;;;AAlCrB,AAAA,AAAA,AAAA,AAASP,AAiBAO;;AAjBT,AAAA,AAAA,AAiBSA;AAjBT,AAiBeA;;;AAjBf,AAAA,AAAA,AAAA,AAASP,AAsDUO;;AAtDnB,AAAA,AAAA,AAsDmBA;AAtDnB,AAuDI,AAACwB,AAAY5B,AAAKC;;;AAvDtB,AAAA,AAAA,AAAA,AAASJ,AAyDSO;;AAzDlB,AAAA,AAAA,AAyDkBA;AAzDlB,AA0DI,AAAMyB,AAAE,AAAS7B;AACXe,AAAE,AAAA,AAAM,AAAG,AAAG1B,AAAEwC,AAAG,AAACC,AAAO/B,AACvB,AAAAgC,AAAiBhC;AAAjBiC,AAAqB,AAAG3C,AAAEwC;AAA1BI,AAAA;AAAA,AAAA,AAAAF,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACrB,AAAAA,AAAAA;AADH;AADR,AAGE,AAAI,AAAA,AAAMG;AAAV;;AAEEA;;;;AA/DR,AAAA,AAAA,AAAA,AAASlB,AAUMO,AAAKO;;AAVpB,AAAA,AAAA,AAUeP;AAVf,AAWI,AAACQ,AAAAA,AAAAA,AAAgBb,AAAAA,AAAIC,AAAAA,AAAKX,AAAAA,AAAEY,AAAAA,AAAIU,AAAAA;;;AAXpC,AAAA,AAAA,AAAA,AAASd,AA8CCO,AAAKoB;;AA9Cf,AAAA,AAAA,AA8CUpB;AA9CV,AA+CI,AAACqB,AAAKD,AAAEpB;;;AA/CZ,AAAA,AAAA,AAAA,AAASP,AAkESO;;AAlElB,AAAA,AAAA,AAkEkBA;AAlElB,AAmEI,AAAMyB,AAAE,AAAS7B;AACXe,AAAE,AAAA,AAAM,AAAG,AAAG1B,AAAEwC,AAAG,AAACC,AAAO/B,AACvB,AAAAmC,AAAiBnC;AAAjBoC,AAAqB,AAAG9C,AAAEwC;AAA1BO,AAAA;AAAA,AAAA,AAAAF,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACxB,AAAAA,AAAAA;AADH;AADR,AAGE,AAAI,AAAA,AAAMG;AAAV;;AAEEA;;;;AAxER,AAAA,AAAA,AAASlB;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAJ,AAAAC,AAAAC,AAASE;AAAT,AAAA,AAAAD,AAAAF,AAAA;;;AAAA;;;AAAA,AAASI,AAAeC,AAAIC,AAAKX,AAAEY,AAAIC,AAAeC;AAAtD,AAAA,AAAAN,AAAwBE,AAAIC,AAAKX,AAAEY,AAAIC,AAAeC;;;AAA7CN,AAoFT,AAAA,AAAA,AAAA+C,AAAMhC;AAAN,AAAA,AAAAiC,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAjC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAkC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMlC,AACFb,AAAIV,AAAEY;AADV,AAEK,AAAAJ,AAAA,AAAA,AAAgBE,AAAI,AAACb,AAAWa,AAAIV,AAAGA,AAAEY;;;AAF9C,AAAA,AAAA,AAAMW,AAGFb,AAAIC,AAAKX,AAAEY;AAHf,AAIK,AAAAJ,AAAA,AAAA,AAAgBE,AAAIC,AAAKX,AAAEY;;;AAJhC,AAAA,AAAA,AAAMW,AAKFb,AAAIC,AAAKX,AAAEY,AAAIC;AALnB,AAMK,AAAAL,AAAA,AAAgBE,AAAIC,AAAKX,AAAEY,AAAIC;;;AANpC,AAAA,AAAA,AAAMU;;AAAN,AAQA,AAAA,AAAMmC,AAAa/C,AAAKgD,AAAMC;AAA9B,AACE,AAAI,AAAA,AAAOD;AAKT,AAAME,AAAQ,AAAOlD;AACfmD,AAAQ,AAAAC,AAAYH;AAD1B,AAEE,AAAA,AAAA,AAACI,AAAWH,AAAMC,AAAUF;;AAC5B,AAAA,AAACK,AAAiBH;;AACpB,AAAMI,AAAK,AAACC,AAASxD;AACfyD,AAAK,AAAA,AAAA,AAAQF,AAAK,AAACG,AAAY1D;AAC/BX,AAAK,AAAA,AAAS,AAAiB,AAAA,AAAK4D,AAAKD;AACzC3D,AAAK,AAAIkE,AACFlE,AACA,AAAOsE,AAAEtE;;AAAT,AACE,AAAI,AAAI4D,AAAI,AAAMQ,AAAKE;AACrBA;;AACA,AAAO,AAAA,AAAKA;;;;;;;AACvBC,AAAU,AAAIL,AACF,AAAMM,AAAG,AAACC,AAAIb,AAAI,AAAA,AAAkBD;AAApC,AACE,AAAI,AAAA,AAAOa;AAAI,AAAA,AAAkBb;;AAAOa;;AAC1C,AAAI,AAAA,AAAMxE,AACR,AAAG4D,AAAI,AAAMQ,AAAK,AAAA,AAAKpE,AACvB4D;AACdC,AAAU,AAAOlD;AACjB+D,AAAU,AAAAC,AAAa,AAAMd,AAAI7D;AAAvB4E,AAA0B,AAAA,AAAGjB;AAA7BkB,AAAsCN;AAAtC,AAAA,AAAAI,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACnB,AAAAA,AAAAA;;AACXoB,AAAe,AAAI,AAAA,AAAInB,AACN,AAAA,AAAO,AAAS,AAAOe,AACvB,AAACP,AAASO;AAC3BZ,AAAU,AAAAC,AAAY,AAAA,AAAA,AAAI,AAAKG,AAAKY;AACpCC,AAAe,AAAID,AACF,AAAMxD,AAAE,AAACmD,AAAIF,AAAU,AAAA,AAAkBZ;AAAzC,AACE,AAAI,AAAA,AAAOrC;AAAG,AAAA,AAAkBqC;;AAAOrC;;AACzC,AAAI,AAAA,AAAIqC,AACN,AAAS,AAAOe,AAChB,AAACM,AAAWN;AA1BrC,AA2BE,AAAA,AAAA,AAACV,AAAWH,AAAMC,AAAU9D;;AAC5B,AAAM8D,AAAQ9D,AAAE0E;;AAChB,AAAA,AAAQ,AAAKR,AAAKY;AAChB,AAAMG,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTC,AAAS,AAAA,AAAkBvB;AADjC,AAEE,AAAIO;AACF,AAAAiB,AAAYnF;AAAZ,AAAA,AAAA,AAAUsE;;AAAV,AAAA,AAAA,AAAAa,AAAUb;AAAV,AACE,AAAMW,AAASX,AAAE,AAAG,AAAA,AAAKA,AAAGY;;AAD9B,AAAA,AAAA,AAAUZ;;;;AAAV;;;;AAEA,AAAAa,AAAYnF;AAAZ,AAAA,AAAA,AAAUsE;;AAAV,AAAA,AAAA,AAAAa,AAAUb;AAAV,AACE,AAAMW,AAASX,AAAE,AAAMF,AAAKE;;AAD9B,AAAA,AAAA,AAAUA;;;;AAAV;;;;;AAEF,AAAMW,AAASjF,AAAE,AAAG,AAAA,AAAI,AAAA,AAAMA,AAAG,AAAMiF,AAAS,AAAA,AAAKjF,AACjC+E;;AACpB,AAAA,AAAME,AAAY,AAAA,AAAKjF;;AACvB,AAAA,AAAM8D,AAAWmB;;AAXrB;;AAYA,AAAA,AAAChB,AAAiBH;;;AAExB,AAAA,AAAMsB,AAAYzE,AAAKgD,AAAML,AAAMM;AAAnC,AACE,AAAI,AAAA,AAAOD;AAET,AAAME,AAAQ,AAAOlD;AACf0E,AAAQ,AAAG,AAASxB,AAAKP;AACzBQ,AAAQ,AAAAC,AAAYsB;AAF1B,AAGE,AAAA,AAACrB,AAAWH,AAAIP,AAAMQ,AAAUuB;;AAChC,AAAA,AAACpB,AAAiBH;;AACpB,AAAMI,AAAK,AAACC,AAASxD;AACfkD,AAAK,AAAOlD;AACZyD,AAAK,AAAA,AAAA,AAAQF,AAAK,AAACG,AAAY1D;AAC/BX,AAAK,AAAA,AAAS,AAAiBsD,AAAMK;AACrC3D,AAAK,AAAIkE,AACFlE,AACA,AAAOsE,AAAEtE;;AAAT,AACE,AAAI,AAAGsD,AAAM,AAAMc,AAAKE;AACtBA;;AACA,AAAO,AAAA,AAAKA;;;;;;;AACvBgB,AAAK,AAAIpB,AACF,AAAOlE,AAAEA;;AAAT,AACE,AAAI,AAAI,AAAA,AAAIA,AAAM,AAAA,AAAM,AAAM6D,AAAI7D;AAChCA;;AACA,AAAO,AAAA,AAAKA;;;;;;AAChB,AAAA,AAAMoE;AACbmB,AAAY,AAAI,AAAA,AAAMvF,AACR,AAAGsD,AACA,AAAIY,AACF,AAAGlE,AAAE,AAAA,AAAkB2D,AACvB,AAAMS,AAAK,AAAA,AAAKpE,AACrBsD;AACdiB,AAAY,AAAIL,AACF,AAAAsB,AAAK,AAAA,AAAkB7B;AAAvB8B,AACK,AAAI,AAAA,AAAMzF,AACR,AAAG4D,AAAI,AAAG5D,AAAE,AAAA,AAAkB2D,AAC9BC;AAHP,AAAA,AAAA4B,AAAAC,AAAAD,AAAAC;AAIA,AAAMC,AAAW,AAAAF,AAAK,AAAMpB,AAAKpE;AAAhByF,AAAmB7B;AAAnB,AAAA,AAAA4B,AAAAC,AAAAD,AAAAC;;AAAjB,AACE,AAAI,AAAA,AAAMzF;AACR,AAAG0F,AAAW,AAAMtB,AAAK,AAAA,AAAKpE;;AAC9B0F;;;AAClBhB,AAAY,AAAAiB,AAAY,AAAM9B,AAAI7D;AAAtB4F,AACY,AAAA,AAAGjC;AADfkC,AAEYN;AAFZO,AAGYvB;AAHZ,AAAA,AAAAoB,AAAAC,AAAAC,AAAAC,AAAAH,AAAAC,AAAAC,AAAAC,AAACV,AAAAA,AAAAA;;AAIbC,AAAY,AAAGC,AAAItF;AACnBqF,AAAY,AAAI,AAAA,AAAMX,AAAW,AAAA,AAAKW,AAASA;AApCrD,AAqCE,AACE,AAAA,AAAOA;AADT;;AAAA,AAIEnB;AACA,AAAMJ,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACRM,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACR2B,AAAQ,AAAI,AAAI,AAAA,AAAMrB,AACN,AAAA,AAAIf,AACJ,AAACQ,AAASO,AAChB,AAAG,AAAA,AAAkBf,AAClB,AAAA,AAAS,AAAiBL,AAAM,AAAA,AAAGK,AACtC,AAACqB,AAAWN;AACtBQ,AAAQ,AAAA,AAAkBvB;AARhC,AASE,AAAA,AAAOW;AACA0B,AAAED;;AADT,AAEE,AAAM,AAAGzB,AAAEe;AAAX,AACE,AAAMjB,AAAKE,AAAE0B;;AACb,AAAO,AAAA,AAAK1B;AAAG,AAAG0B,AAAEd;;;;;AAFtB;;;;AAGF,AAAM,AAAA,AAAGG;AAAT,AACE,AAAMjB,AAAK,AAAA,AAAKiB,AAAS,AAAGzB,AAAIN;;AADlC;;AAEA,AAAA,AAAMc,AAAQiB;;AACd,AAAA,AAACrB,AAAWH,AAAI,AAAI,AAAA,AAAMa,AAAW,AAAA,AAAK1E,AAAGA,AACjC8D,AACAuB;;AACZ,AAAA,AAAQ,AAAA,AAAMX;AACZ,AAAA,AAAMZ,AAAUY;;AADlB;;AAEA,AAAA,AAAMZ,AAAWM;;AACjB,AAACH,AAAa,AAAQtD,AAAMmD;;AA5BhC,AA+BE,AAAMA,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTmB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AADf,AAEE,AAAA,AAAOX;AAAItE,AAAEA;;AAAb,AACE,AAAM,AAAGsE,AAAEe;AAAX,AACE,AAAMJ,AAASX,AAAE,AAAG,AAAMF,AAAKpE,AAAGsD;;AAClC,AAAO,AAAA,AAAKgB;AAAG,AAAA,AAAKtE;;;;;AAFtB;;;;AAGF,AAAA,AAAMiF,AAAYI;;AAClB,AAAA,AAACrB,AAAWH,AAAI,AAAI,AAAA,AAAMa,AAAW,AAAA,AAAK1E,AAAGA,AACjC8D,AACAuB;;AACZ,AAAA,AAAQ,AAAA,AAAMX;AACZ,AAAA,AAAMZ,AAAUY;;AADlB;;AAEA,AAAA,AAAMZ,AAAWmB;;AACjB,AAAChB,AAAa,AAAQtD,AAAMmD;;;;;;AAEtC,AAAA;AAAA,AAEA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASuC;;AAAT,AAAA,AAAA,AAEapF;AAFb,AAGI,AAACD,AAAQC;;;AAHb,AAAA,AAAA,AAAA,AAASoF,AA8LGpF,AAAKoH;;AA9LjB,AAAA,AAAA,AA8LYpH;AA9LZ,AA+LI,AAAA,AAAMA,AAAKoH;;;AA/Lf,AAAA,AAAA,AAAA,AAAShC,AAiMGpF,AAAKoH,AAAEpB;;AAjMnB,AAAA,AAAA,AAiMYhG;AAjMZ,AAkMI,AAAMA,AAAKoH,AAAEpB;;;AAlMjB,AAAA,AAAA,AAAA,AAASZ,AAmNMpF,AAAKiC,AAAEoF;;AAnNtB,AAAA,AAAA,AAmNerH;AAnNf,AAoNI,AAAA,AAAOjB;AAAP,AACOsE;AACAgE,AAAKA;AACLzE,AAAK,AAAY5C,AAAKjB;AACtBuI,AAAK,AAAA,AAAK,AAAS1E;AACnBqB,AAAK,AAAA,AAAKqD;;AALjB,AAME,AAAMD,AAAK,AAAAE,AAAGF;AAAHG,AAAQ,AAAGzI,AAAEsE;AAAboE,AAAgB,AAAM7E,AAAIS;AAA1B,AAAA,AAAAkE,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACxF,AAAAA,AAAAA;;AAAZ,AACE,AAAI,AAAC0F,AAASN;AAAd,AAAAK,AACGL;;AACD,AAAI,AAAGhE,AAAEiE;AACP,AAAOvI;AAAE,AAAA,AAAKsE;AAAGgE;AAAKzE;AAAI0E;AAAIrD;;;;;;;;;AAC9B,AAAMlF,AAAE,AAAGA,AAAEkF;AAAb,AACE,AAAI,AAAGlF,AAAEuG;AACP,AAAM1C,AAAI,AAAY5C,AAAKjB;AACrBsF,AAAI,AAASzB;AACb0E,AAAI,AAAA,AAAKjD;AAFf,AAGE,AAAOtF;AAAP;AAAWsI;AAAKzE;AAAI0E;AAAIjD;;;;;;;;;AAC1BgD;;;;;;;;AArOhB,AAAA,AAAA,AAAA,AAASjC,AAsCApF,AAAKjB;;AAtCd,AAAA,AAAA,AAsCSiB;AAtCT,AAuCI,AAAI,AAAK,AAAA,AAAMjB,AAAG,AAAGA,AAAEuG;AACrB,AAAMO,AAAS,AAAGP,AAAI,AAASE;AAA/B,AACE,AAAI,AAAIK,AAAS9G;AACf,AAAMyG,AAAK,AAAGzG,AAAE8G;;AAChB,AAAO9G,AAAEA;AAAEW,AAAK6F;AAAK7C,AAAMA;;AAA3B,AACE,AAAI,AAAA,AAAOA;AACT,AAAME,AAAI,AAAOlD;AAAjB,AACE,AAAMkD,AAAI,AAAA,AAAS,AAAiB7D,AAAE2D;;AACxC,AAAI,AAACQ,AAASxD;AACZ,AAAMkD,AAAI,AAAOlD;AACXoG,AAAI,AAAA,AAAS,AAAiB/G,AAAE2D;AADtC,AAEE,AAAO3D,AAAMA;AACNW,AAAM,AAAMkD,AAAIkD;AAChBpD,AAAM,AAAA,AAAGA;;AAFhB,AAGE,AAAME,AAAI,AAAOlD;AACXoG,AAAI,AAAA,AAAS,AAAiB/G,AAAE2D;AADtC,AAEE,AAAI,AAAA,AAAOA;AACT,AAAME,AAAIkD;;AACV,AAAO/G;AAAE,AAAM6D,AAAIkD;AAAK,AAAA,AAAGpD;;;;;;;;;AACnC,AAAME,AAAK,AAAOlD;AACZyD,AAAK,AAACC,AAAY1D;AAClBoG,AAAK,AAAOzC,AAAE,AAAA,AAAS,AAAiBtE,AAAE2D;;AAArC,AACE,AAAI,AAAG3D,AAAE,AAAMoE,AAAKE;AAClBA;;AACA,AAAO,AAAA,AAAKA;;;;;;;AACrBtE,AAAK,AAAI,AAAA,AAAO+G,AACT/G,AACA,AAAGA,AAAE,AAAMoE,AAAK,AAAA,AAAK2C;AARlC,AASE,AAAO/G;AAAE,AAAM6D,AAAIkD;AAAK,AAAA,AAAGpD;;;;;;;;;;;AACvC,AAACqD,AAA2BhH,AAAEuG;;;;AApEpC,AAAA,AAAA,AAAA,AAASF,AAsEApF,AAAKjB,AAAEiH;;AAtEhB,AAAA,AAAA,AAsEShG;AAtET,AAuEI,AAAI,AAAK,AAAA,AAAIjB,AAAK,AAAGA,AAAEuG;AACrB,AAAMtF,AAAKjB;;AACXiH;;;;AAzEN,AAAA,AAAA,AAAA,AAASZ,AAMMpF,AAAKC,AAAOC;;AAN3B,AAAA,AAAA,AAMeF;AANf,AAOI,AAAA,AAAA,AAAA,AAACG,AAAqBF,AAAOG,AAAsBF,AAAKF;;;AAP5D,AAAA,AAAA,AAAA,AAASoF,AAoKIpF,AAAKjB,AAAEkH;;AApKpB,AAAA,AAAA,AAoKajG;AApKb,AAqKI,AACE,AAAK,AAAA,AAAMjB,AAAG,AAAGA,AAAEuG;AACnB,AAAMO,AAAS,AAAc7F;AAA7B,AACE,AAAI,AAAIjB,AAAE8G;AACR,AAAMM,AAAS,AAAArD,AAAY,AAAS0C;AAC9BM,AAAI,AAAG/G,AAAE8G;AADf,AAEE,AAAA,AAAA,AAAC9C,AAAWyC,AAAOW,AAAW,AAASX;;AACvC,AAAMW,AAASL,AAAIG;;AACnB,AAAAb,AAAA,AAASE,AAAI5C,AAAM6C,AAAKY,AAASvG;;AACnC,AAAAwF,AAAA,AAASE,AAAI5C,AAAM,AAACwE,AAASxE,AAAM6C,AAAKxG,AAAEkH,AAAKT,AAAK5F;;;AAT1D,AAWE,AAAIb,AAAEuG;AAAK,AAAOtF,AAAKiG;;AAXzB,AAYQ,AAACF,AAA2BhH,AAAEuG;;;;;;AAjL1C,AAAA,AAAA,AAAAN,AAASI;;AAAT,AAAA,AAAA,AAAA,AAASA,AA4UIpF;;AA5Ub,AAAA,AAAA,AA4UaA;AA5Ub,AA6UIA;;;AA7UJ,AAAA,AAAA,AAAA,AAASoF,AAcCpF;;AAdV,AAAA,AAAA,AAcUA;AAdV,AAeIJ;;;AAfJ,AAAA,AAAA,AAAA,AAASwF,AAkCEQ;;AAlCX,AAAA,AAAA,AAkCWA;AAlCX,AAmCIN;;;AAnCJ,AAAA,AAAA,AAAA,AAASF,AA4EApF;;AA5ET,AAAA,AAAA,AA4ESA;AA5ET,AA6EI,AAAA,AAAMA;;;AA7EV,AAAA,AAAA,AAAA,AAASoF,AA+EApF;;AA/ET,AAAA,AAAA,AA+ESA;AA/ET,AAgFI,AAAA,AAAMA;;;AAhFV,AAAA,AAAA,AAAA,AAASoF,AA8HCpF;;AA9HV,AAAA,AAAA,AA8HUA;AA9HV,AA+HI,AAAM,AAAA,AAAMsF;AAAZ,AACE,AAAMtF,AAAK,AAAA,AAAKsF;;AADlB;;;;AA/HJ,AAAA,AAAA,AAAA,AAASF,AAkIApF;;AAlIT,AAAA,AAAA,AAkISA;AAlIT,AAmII,AACE,AAAA,AAAOsF;AACP,AAAO,AAAA9C,AAAA;;AAFT,AAIE,AAAA,AAAM8C;AACN,AAACwB,AAAW,AAAAD,AAAiCjH;;AAL/C,AAOE,AAAA,AAAG,AAAS4F;AACZ,AAAMW,AAAS,AAAArD,AAAY,AAAA,AAAK,AAAS0C;AAAzC,AACE,AAAA,AAAA,AAACzC,AAAWyC,AAAOW,AAAW,AAASA;;AACvC,AAAAf,AAAA,AAAS,AAAA,AAAKE,AAAK5C,AAAM6C,AAAKY,AAASvG;;AAV3C,AAaE,AAAMuG,AAAS,AAAYnG,AAAK,AAAA,AAAGsF;AAC7ByB,AAAS,AAAc/G;AACvBsG,AAAS,AAACU,AAAStE,AAAMqE,AAAS,AAAQxB,AAAMA;AAFtD,AAGE,AACE,AAAA,AAAMe;AACN,AAAAlB,AAAA,AAAS,AAAA,AAAKE,AAAK5C,AAAMuE,AAAWd,AAASvG;;AAF/C,AAIE,AAAK,AAAA,AAAG8C,AACH,AAAA,AAAM,AAAA,AAAM,AAAO4D;AACxB,AAAAlB,AAAA,AAAS,AAAA,AAAKE,AACL,AAAA,AAAG5C,AACH,AAAA,AAAM,AAAO4D,AACbH,AACAvG;;AAVX,AAcE,AAAAwF,AAAA,AAAS,AAAA,AAAKE,AAAK5C,AAAM4D,AAASH,AAASvG;;;;;;;;;;AAjKrD,AAAA,AAAA,AAAA,AAASwF,AAoLCpF;;AApLV,AAAA,AAAA,AAoLUA;AApLV,AAqLI,AAAI,AAAA,AAAMsF;AACR,AAAA6B,AAAA,AAAOnH,AAAK,AAAA,AAAKsF;;AADnB;;;;AArLJ,AAAA,AAAA,AAAA,AAASF,AAuBCpF;;AAvBV,AAAA,AAAA,AAuBUA;AAvBV,AAwBI,AAAA+B,AAAqClC;AAArC,AAAA,AAAA,AAAA,AAAAkC,AAAA;AAAAA;;AAAA,AAAAA,AAAA,AAAc/B,AAAKgC;AAAnB,AAAA,AAAAD,AAAqClC;;AAArCkC;;;;AAxBJ,AAAA,AAAA,AAAA,AAASqD,AAmBEpF,AAAKyF;;AAnBhB,AAAA,AAAA,AAmBWzF;AAnBX,AAoBI,AAACQ,AAAiBR,AAAKyF;;;AApB3B,AAAA,AAAA,AAAA,AAASL,AA4OSpF;;AA5OlB,AAAA,AAAA,AA4OkBA;AA5OlB,AA6OI,AAAA6H,AAAavC;AAAbwC,AACapF;AADbqF,AAEa,AAACI,AAAc5C;AAF5ByC,AAGa,AAACI,AAAc5C;AAH5ByC,AAIa,AAASzC;AAJtB,AAAA,AAAAqC,AAAAC,AAAAC,AAAAC,AAAAC,AAAAJ,AAAAC,AAAAC,AAAAC,AAAAC,AAACC,AAAAA,AAAAA;;;AA7OL,AAAA,AAAA,AAAA,AAAS9C,AA0HEQ;;AA1HX,AAAA,AAAA,AA0HWA;AA1HX,AA2HI,AAACxE,AAAU,AAAAyF,AAAiCjH;;;AA3HhD,AAAA,AAAA,AAAAoF,AAASI;;AAAT,AAAA,AAAA,AAAA,AAASA,AAoPGpF,AAAKqC,AAAMM;;AApPvB,AAAA,AAAA,AAoPY3C;AApPZ,AAqPI,AAAMqI,AAAQ,AAAG1F,AAAIN;AAArB,AACE,AACE,AAAI,AAAA,AAAMA,AAAO,AAAGM,AAAI2C;AACxB,AAAO,AAAA9C,AAAA;;AAFT,AAIE,AAAIH,AAAMM;AAEV,AAAC2F,AAAMtI;;AANT,AAQE,AAAGqC,AAAMM;AACT,AAAO,AAAAH,AAAA;;AATT,AAYE,AAAMqD,AAAS,AAAc7F;AAA7B,AACE,AAAI,AAAIqC,AAAMwD;AACZ,AAAMM,AAAS,AAAArD,AAAYuF;AAA3B,AACE,AAAA,AAACtF,AAAWyC,AAAK,AAAGnD,AAAMwD,AACdM,AACAkC;;AACZ,AAAAjD,AAAA,AAAA,AAASiD,AAAUpB,AAAWd,AAASvG;;AACzC,AAAM2I,AAAU,AAAG5F,AAAIkD;AACjBS,AAAU,AAAIiC,AACFhD,AACA,AAAC9C,AAAY8C,AAAK7C,AAAMC;AACpC2D,AAAU,AAAI,AAAA,AAAOjE,AACTiE,AACA,AAACnC,AAAWmC,AAAS5D,AAAML,AACf,AAAAkC,AAAK5B;AAAL6B,AAASqB;AAAT,AAAA,AAAAtB,AAAAC,AAAAD,AAAAC;;AACxB2B,AAAU,AAAIoC,AACF,AAAMnE,AAAS,AAAGzB,AAAIkD;AAChBM,AAAS,AAAArD,AAAYsB;AAD3B,AAEE,AAAA,AAAA,AAACrB,AAAWyC,AAAOW,AAAW/B;;AAC9B+B;AACF,AAAY,AAAAf,AAAA,AAASiD,AAAQ3F,AAAM4D,AACd,AAAQ1G,AACjB,AAAA,AAAKyI;AAC7B/B,AAAU,AAAIiC,AACFjC,AACA,AAACU,AAAStE,AAAM2F,AAAQ,AAAQ/B,AACtBA;AAnB5B,AAoBE,AAAI,AAAA,AAAMA;AACR,AAAAlB,AAAA,AAAA,AAASiD,AAAUpB,AAAWd,AAASvG;;AACvC,AAAOmF,AAAEuB;AACF7F,AAAEiC;;AADT,AAEE,AAAI,AAAK,AAAA,AAAGjC,AACH,AAAA,AAAM,AAAA,AAAM,AAAOsE;AAC1B,AAAO,AAAA,AAAM,AAAOA;AAAM,AAAA,AAAGtE;;;;;AAC7B,AAAA2E,AAAA,AAASiD,AAAQ5H,AAAEsE,AAAEoB,AAASvG;;;;;;;;;;;;AApSlD,AAAA,AAAA,AAAAoF,AAASI;;AAAT,AAAA,AAAA,AAAA,AAASA,AA2SQpF;;AA3SjB,AAAA,AAAA,AA2SiBA;AA3SjB,AA4SI,AAAGsF,AAAI,AAASE;;;AA5SpB,AAAA,AAAA,AAAA,AAASJ,AA8SMpF,AAAKjB;;AA9SpB,AAAA,AAAA,AA8SeiB;AA9Sf,AA+SI,AAAI,AAAK,AAAA,AAAMjB,AAAG,AAAGA,AAAEuG;AACrB,AAAI,AAAIvG,AAAE,AAAciB;AACtBwF;;AACA,AAAOzG,AAAEA;AAAEW,AAAK6F;AAAK7C,AAAMA;;AAA3B,AACE,AAAI,AAAA,AAAOA;AACT,AAAOhD;;AACP,AAAI,AAACwD,AAASxD;AACZ,AAAOA,AAAM,AAAM,AAAOA,AACP,AAAA,AAAS,AAAiBX,AAAE2D;AACxCA,AAAM,AAAA,AAAGA;;AAFhB,AAGE,AAAI,AAAA,AAAOA;AACT,AAAOhD;;AACP,AAAO,AAAM,AAAOA,AACP,AAAA,AAAS,AAAiBX,AAAE2D;AAClC,AAAA,AAAGA;;;;;;;;AACd,AAAMS,AAAK,AAACC,AAAY1D;AAClB2D,AAAK,AAAOA,AAAE,AAAA,AAAS,AAAiBtE,AAAE2D;;AAArC,AACE,AAAI,AAAG3D,AAAE,AAAMoE,AAAKE;AAClBA;;AACA,AAAO,AAAA,AAAKA;;;;;;;AACrBtE,AAAK,AAAI,AAAA,AAAMsE,AACR,AAAGtE,AAAE,AAAMoE,AAAK,AAAA,AAAKE,AACrBtE;AAPb,AAQE,AAAOA;AACA,AAAM,AAAOW,AAAM2D;AACnB,AAAA,AAAGX;;;;;;;;;;;AACpB,AAACqD,AAA2BhH,AAAEuG;;;;AAzUpC,AAAA,AAAA,AAAA,AAASF,AA4MGpF,AAAKiC;;AA5MjB,AAAA,AAAA,AA4MYjC;AA5MZ,AA6MI,AAACkC,AAAUlC,AAAKiC;;;AA7MpB,AAAA,AAAA,AAAA,AAASmD,AA+MGpF,AAAKiC,AAAEI;;AA/MnB,AAAA,AAAA,AA+MYrC;AA/MZ,AAgNI,AAACkC,AAAUlC,AAAKiC,AAAEI;;;AAhNtB,AAAA,AAAA,AAAA,AAAS+C,AA0LEpF,AAAKoH,AAAEtI;;AA1LlB,AAAA,AAAA,AA0LWkB;AA1LX,AA2LI,AAAUA,AAAKoH,AAAEtI;;;AA3LrB,AAAA,AAAA,AAAA,AAASsG,AA2BApF;;AA3BT,AAAA,AAAA,AA2BSA;AA3BT,AA4BI,AACE,AAAA,AAAOsF;AADT;;AAAA,AAEE,AAAA,AAAO,AAActF;AAAO,AAAC0F,AAAUF;;AAFzC,AAGQ,AAAA,AAAA,AAACG,AAAgB3F;;;;;;AA/B7B,AAAA,AAAA,AAAA,AAASoF,AAUMpF,AAAKJ;;AAVpB,AAAA,AAAA,AAUeI;AAVf,AAWI,AAAAoF,AAASE,AAAI5C,AAAM6C,AAAKC,AAAK5F,AAAKC;;;AAXtC,AAAA,AAAA,AAAA,AAASuF,AAmFCpF,AAAKiG;;AAnFf,AAAA,AAAA,AAmFUjG;AAnFV,AAoFI,AAAI,AAAA,AAAG,AAASwF;AACd,AAAMU,AAAS,AAASV;AAClBW,AAAS,AAAArD,AAAY,AAAA,AAAKoD;AADhC,AAEE,AAAA,AAAA,AAACnD,AAAWyC,AAAOW,AAAWD;;AAC9B,AAAMC,AAASD,AAASD;;AACxB,AAAAb,AAAA,AAAS,AAAA,AAAKE,AAAK5C,AAAM6C,AAAKY,AAASvG;;AACzC,AAAMwG,AAAU,AAACpD,AAAa,AAAQuC,AAAMC;AACtCW,AAAU,AAAMtD,AAAQ,AAAA;AAAd,AACE,AAAA,AAAMA,AAAUoD;;AAChBpD;;AAHlB,AAIE,AAAI,AAACwD,AAAUd,AAAK7C,AAAM4C;AACxB,AAAI,AAACpC,AAASqC;AACZ,AAAM1C,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTyD,AAAS,AAACtD,AAAa,AAAQuC,AAAM1C;AAD3C,AAEE,AAAA0D,AAAM1D;AAAN,AAAA,AAAA0D,AAAA,AACUhB;;AADV,AAAAgB,AAAA,AAEU,AAACC,AAAShB,AAAK,AAAQD,AAAM7C,AAAM0D;;AAF7CG;AAGA,AAAAnB,AAAA,AAAS,AAAA,AAAKE,AAAK,AAAA,AAAG5C,AAAS4D,AAASH,AAASvG;;AACnD,AAAMiD,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTmB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTsC,AAAS,AAACtD,AAAa,AAAQuC,AAAM1C;AACrC4D,AAAiB,AAAA,AAAM,AAACrD,AAAYmC;AAH1C,AAIE,AAAAmB,AAAM7D;AAAN,AAAA,AAAA6D,AAAA,AACWnB;;AADX,AAAAmB,AAAA,AAEW,AAACF,AAAShB,AAAK,AAAQD,AAAM7C,AAAM0D;;AAF9C,AAAAM,AAAA,AAGW1C;;AAHX0C;AAIA,AAAAC,AAAM3C;AAAN,AAAA,AAAA2C,AAAA,AACWF;;AADX,AAAAE,AAAA,AAEW,AAAA,AAAGF;;AAFd,AAAAE,AAAA,AAAA;;AAAAA;AAIA,AAAAvB,AAAA,AAAS,AAAA,AAAKE,AAAK,AAAA,AAAG5C,AAAS4D,AAASH,AAASvG;;;AACrD,AAAAwF,AAAA,AAAS,AAAA,AAAKE,AAAK5C,AACV,AAACkE,AAAUlE,AAAM4C,AAAI,AAAQC,AAAMA,AAAKa,AACxCD,AACAvG;;;;;AAtHnB,AAAA,AAAA,AAAA,AAASwF;;AAATH,AAqMiBmC;;AArMjB,AAAA,AAAAnC,AAAA;AAAA,AAAA,AAAAA,AAqMYjF;AArMZ,AAsMI,AAAMA,AAAKoH;;AAtMfnC,AAwMiBmC,AAAEpB;;AAxMnB,AAAA,AAAAf,AAAA;AAAA,AAAA,AAAAA,AAwMYjF;AAxMZ,AAyMI,AAAMA,AAAKoH,AAAEpB;;AAzMjBf,AAwMiBmC,AAAEpB;;;AAxMnBf,AAwMiBmC;;AAxMjBnC,AAwMiBmC,AAAEpB;;;;;;;;;;AAxMnB,AAAA,AAAA,AAAA,AAAAf,AAAAC,AAASE;;AAAT,AAAA,AAAAH,AAAA;AAAA,AAAA,AAAA,AAAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAAE,AAAAD;;;AAAA,AAAA,AAAA,AAAA,AAASE,AAqMQgC;;AArMjB,AAAA,AAAA,AAqMYpH;AArMZ,AAsMI,AAAMA,AAAKoH;;;AAtMf,AAAA,AAAA,AAAA,AAAShC,AAwMQgC,AAAEpB;;AAxMnB,AAAA,AAAA,AAwMYhG;AAxMZ,AAyMI,AAAMA,AAAKoH,AAAEpB;;;AAzMjB,AAAA,AAAA,AAAA,AAASZ,AAwOIpF,AAAKyF;;AAxOlB,AAAA,AAAA,AAwOazF;AAxOb,AAyOI,AAAC4H,AAAgB5H,AAAKyF;;;AAzO1B,AAAA,AAAA,AAAAT,AAASI;;AAAT,AAAA,AAAA,AAAA,AAASA,AAuSIpF,AAAKyF;;AAvSlB,AAAA,AAAA,AAuSazF;AAvSb,AAwSI,AAAAwI,AAAcxI;AAAdyI,AAAmB,AAACxJ,AAASwG;AAA7B,AAAA,AAAA+C,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;;;AAxSL,AAAA,AAAA,AAAStD;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAjG,AAAAC,AAAAC,AAAS+F;AAAT,AAAA,AAAA9F,AAAAF,AAAA;;;AAAA;;;AAAA,AAASiG,AAAQC,AAAI5C,AAAM6C,AAAKC,AAAK5F,AAAeC;AAApD,AAAA,AAAAuF,AAAiBE,AAAI5C,AAAM6C,AAAKC,AAAK5F,AAAeC;;;AAA3CuF,AA+UT,AAAA,AAAA,AAAA,AAAA,AAAAJ,AACE6B;;AADF,AAAA,AAAA,AACEA,AACA,AAAW7G;AAAX,AAAA,AAAA,AAAWA;AAAX,AACE,AAAAoF,AAAA,AAAS,AAAChD,AAAMpC,AAAM,AAASA,AAAM,AAAQA,AAAM,AAAQA,AAClD,AAAC2I,AAAK3I;;;AAJnB,AAAA,AAAA,AAAA,AAAAgF,AAME4D;;AANF,AAAA,AAAA,AAMEA,AACA,AAAW5I;AAAX,AAAA,AAAA,AAAWA;AAAX,AACE,AAAMlB,AAAM,AAAKkB;AACXqC,AAAM,AAASrC;AACf2C,AAAM,AAAO3C;AAFnB,AAGE,AAAC6I,AAAQ,AAAC5J,AAASH,AAAGuD,AAAMM;;AAElC,AAAA,AAAMmG,AAAepJ,AAAKqJ,AAAKC;;AAA/B,AACE,AACE,AAAID,AAAKC;AACTtJ;;AAFF,AAIE,AAACwD,AAASxD;AACV,AAAO,AAACsD,AAAa,AAAQtD,AAAM,AAAAuJ,AAAM,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAN,AAAA,AAAAA,AAAA,AAA8BvJ;;AAA9BuJ;;AAC5B,AAAA,AAAKF;AACLC;;;;;;AAPT,AAUE,AAAO,AAAChG,AAAa,AAAQtD,AACR,AAAAwJ,AAAM,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAN,AAAA,AAAAA,AAAA,AACUxJ;;AADV,AAAAwJ,AAAA,AAGQ,AAAAC,AAAM,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAN,AAAA,AAAAA,AAAA,AACW,AAACpF,AAAWrE;;AADvB,AAAAyJ,AAAA,AAAA;;AAAAA;;;AAHRD;;AAMd,AAAA,AAAKH;AACLC;;;;;;;;;;;AAEX,AAAA,AAAMI,AAAY1J,AAAKgD;AAAvB,AACE,AAAME,AAAI,AAAOlD;AAAjB,AACE,AAAI,AAAA,AAAOgD;AACT,AAASE;;AACT,AAAI,AAACM,AAASxD;AACZ,AAAC2J,AAAazG;;AACd,AAAMO,AAAK,AAACC,AAAY1D;AAAxB,AACE,AAAA,AAAMyD;;;;AAEhB,AAAA,AAAMmG,AAAsB5J,AAAKgD;AAAjC,AAEE,AAAME,AAAI,AAAOlD;AACX6J,AAAI,AAAA,AAAG7G;AADb,AAEE,AAAI,AAACQ,AAASxD;AACZ,AAAA,AAAOX;AAAP,AAAWyK;;AAAX,AACE,AAAI,AAAA,AAAIzK;AACNyK;;AACA,AAAAC,AAAe,AAAM7G,AAAI7D;AAAzB,AAAA,AAAA0K;AAAA,AAAAA,AAASC;AAAT,AACE,AAAO,AAAA,AAAK3K;AAAG,AAAGyK,AAAI,AAACJ,AAAWM,AAAMH;;;;;AACxCC;;;;;;AACN,AAAMlC,AAAI,AAAA,AAAM,AAAClE,AAAY1D;AAA7B,AACE,AAAA,AAAOX;AAAP,AAAWyK;;AAAX,AACE,AAAI,AAAIzK,AAAEuI;AACRkC;;AACA,AAAME,AAAM,AAAM9G,AAAI7D;AAAtB,AACE,AAAO,AAAA,AAAKA;AAAG,AAAGyK,AAAI,AAACJ,AAAWM,AAAMH;;;;;;;;;AAEtD,AAAA,AAAMI,AAAU/G;AAAhB,AACE,AAAA,AAAAgH,AAACC;AAAD,AAAS,AAAAD;AAAU,AAACE,AAAK,AAACT,AAAazG,AAAKA;;AAE9C,AAAA,AAAMmH,AACHC,AAAGC,AAAKC,AAAGC,AAAKC;AADnB,AAEE,AAAMC,AAAK,AAAA,AAACjB,AAAWY;AACjBM,AAAK,AAAA,AAAClB,AAAWc;AACjBK,AAAK,AAAGF,AAAKC;AACbE,AAAK,AAAA,AAAClB,AAAqBU;AAC3BS,AAAK,AAAA,AAACnB,AAAqBY;AAC3BQ,AAAK,AAAGF,AAAKC;AACbE,AAAK,AAAGJ,AAAE,AAAA,AAAK,AAAA,AAACK,AAAK,AAAA,AAAKF;AANhC,AAOE,AACE,AAAIC,AAAExM,AAAA;AACN,AAAO6L,AAAGE;;AAFZ,AAIE,AAAA,AAAI,AAAGM,AAAKC;AACZ,AAAMxH,AAAQ,AAAA,AAAO,AAAA,AAACO,AAAIkH;AACpB7H,AAAQ,AAAAC,AAAY,AAAA,AAAA,AAAIG;AACxB4H,AAAQ,AAAA,AAAC7H,AAAiBH;AAFhC,AAGE,AAAA,AAAO9D;AACA+L,AAAG,AAAA,AAACC,AACc,AAACC,AAAO,AAACrB,AAAS,AAAOK,AACjB,AAACL,AAAS,AAAOO;;AAHlD,AAIE,AAAAe,AAAA,AAAAC,AAAmBJ;AAAnB,AAAA,AAAAG;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAA,AAAAG,AAAAD,AAAaE;AAAb,AACE,AAAMd,AAAE,AAAAzH,AAAY,AAACV,AAAMiJ;AAA3B,AACE,AAAA,AAAOtM;AAAIuM,AAAG,AAACJ,AAAIG;;AAAnB,AACE,AAAMC;AAAN,AACE,AAAMf,AAAExL,AAAE,AAACqM,AAAME;;AACjB,AAAO,AAAA,AAAKvM;AAAG,AAACwM,AAAKD;;;;;AAFvB;;;;AAGF,AAAMzI,AAAQ9D,AAAE,AAAA,AAACiE,AAAiBuH;;AAClC,AAAO,AAAA,AAAKxL;AAAG,AAACwM,AAAKT;;;;;AAPzB;;;;AAQF,AAAA,AAAQ7H;AACN,AAAA,AAAMJ,AAAW,AAAA,AAAC2I,AAAiBd;;AADrC;;AAEA,AAAM,AAAON,AAAoBK;;AACjC,AAAA,AAAOI;;AAvBX,AA0BE,AAAM5H,AAAS,AAAA,AAAO,AAAA,AAACO,AAAIkH;AACrBe,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTC,AAAS,AAAA5I,AAAY,AAAA,AAAA,AAAIG;AACzB4H,AAAS,AAAA,AAAC7H,AAAiByI;AAC3BE,AAAS,AAAA,AAAC3I,AAAiB0I;AAJjC,AAKE,AAAA,AAAO3M;AACA+L,AAAG,AAAA,AAACC,AACc,AAACC,AAAO,AAACrB,AAAS,AAAOK,AACjB,AAACL,AAAS,AAAOO;;AAHlD,AAIE,AAAAe,AAAA,AAAAC,AAAmBJ;AAAnB,AAAA,AAAAG;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAA,AAAAG,AAAAD,AAAaE;AAAb,AACE,AAAMd,AAAE,AAAAzH,AAAY,AAACV,AAAMiJ;AAA3B,AACE,AAAA,AAAOtM;AAAIuM,AAAG,AAACJ,AAAIG;;AAAnB,AACE,AAAMC;AAAN,AACE,AAAMf,AAAExL,AAAE,AAACqM,AAAME;;AACjB,AAAO,AAAA,AAAKvM;AAAG,AAACwM,AAAKD;;;;;AAFvB;;;;AAGF,AAAI,AAAA,AAAGvM;AACL,AAAM0M,AAAS1M,AAAE,AAAA,AAACiE,AAAiBuH;;AACnC,AAAMmB,AAAS,AAAA,AAAG3M,AAAM,AAAA,AAACiE,AAAiBuH;;;AAC5C,AAAO,AAAA,AAAKxL;AAAG,AAACwM,AAAKT;;;;;AATzB;;;;AAUF,AAAA,AAAQ7H;AACN,AAAA,AAAMyI,AAAY,AAAA,AAACF,AAAiB,AAAA,AAAGd;;AADzC;;AAEA,AAAM,AAAON,AAAoB,AAAA,AAAQI;;AACzC,AAAOK,AAAOc;;;;;AAEtB,AAAA,AAAMC,AAAWlM,AAAKgD,AAAM4C;AAA5B,AACE,AAAM1C,AAAK,AAAOlD;AACZyD,AAAK,AAAI,AAACD,AAASxD,AACZ,AAAC8L,AAAe9I,AAAM4C,AACtB,AAAClC,AAAY1D;AACpB6J,AAAK,AAAIpG,AAAK,AAAA,AAAMA,AAAS,AAACkG,AAAazG;AAC3CiJ,AAAK,AAAUC,AAAE/G;AAAZ,AACE,AAAMnC,AAAK,AAAOkJ;AACZ3I,AAAK,AAAI,AAACD,AAAS4I,AACZ,AAACN,AAAe,AAAA,AAAG9I,AAASqC,AAC5B,AAAC3B,AAAY0I;AACpBC,AAAK,AAAI5I,AAAK,AAAA,AAAMA,AAAS,AAACkG,AAAazG;AAJjD,AAKE,AAACoJ,AAAIC,AACA,AAACnC,AAAKiC,AAAInJ,AACV,AAACkH,AAAKiC,AAAI,AAACC,AAAIE,AAAE/I,AAAK,AAAA,AAAChC,AAAOgC;;AAblD,AAcE,AAAC0G,AAAOgC,AAAK,AAAC/B,AAAKP,AAAG3G,AAAK,AAACkH,AAAKP,AAAG,AAACyC,AAAIE,AAAE/I,AAAK,AAAA,AAAChC,AAAOgC;;AAE5D,AAAA,AAAMgJ,AACHzJ,AAAMsH,AAAGC,AAAKC,AAAGC,AAAKC;AADzB,AAEE,AAAI,AAAA,AAAMF;AACR,AAAA,AAAOF;;AACP,AAAMK,AAAK,AAACjB,AAAWY,AAAGtH;AACpB4H,AAAK,AAAClB,AAAWc,AAAGxH;AACpB6H,AAAK,AAAGF,AAAKC;AACbE,AAAK,AAAClB,AAAqBU,AAAGtH;AAC9B+H,AAAK,AAACnB,AAAqBY,AAAGxH;AAC9BgI,AAAK,AAAGF,AAAKC;AACbE,AAAK,AAAGJ,AAAE,AAAA,AAAK,AAAA,AAACK,AAAK,AAAA,AAAKF;AANhC,AAOE,AACE,AAAIC,AAAExM,AAAA;AACN,AAAO6L,AAAGE;;AAFZ,AAIE,AAAA,AAAI,AAAGM,AAAKC;AACZ,AAAM5H,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTmB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACT6G,AAAS,AAAA,AAAC7H,AAAiBH;AAFjC,AAGE,AAAA,AAAO9D;AACA+L,AAAG,AAAA,AAACC,AACc,AAACC,AAAO,AAACY,AAAU5B,AAAGtH,AAAMuH,AACpB,AAAC2B,AAAU1B,AAAGxH,AAAMyH;;AAHrD,AAIE,AAAAc,AAAA,AAAAC,AAAmBJ;AAAnB,AAAA,AAAAG;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAA,AAAAG,AAAAD,AAAaE;AAAb,AACE,AAAMd,AAAE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACFxF,AAAE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AADR,AAEE,AAAA,AAAMwF,AAAKxF;;AACX,AAAA,AAAMA,AAAK,AAAC3C,AAAMiJ;;AAClB,AAAA,AAAOtM;AAAP,AAAWmC;AAAI6K,AAAI,AAACb,AAAIG;;AAAxB,AACE,AAAAJ,AAAA,AAAAC,AAAsBa;AAAtB,AAAA,AAAAd;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAAmB,AAAA,AAAAhB,AAAAD;AAAA,AAAAkB,AAAAD,AAAA,AAAA,AAAcE;AAAd,AAAAD,AAAAD,AAAA,AAAA,AAAiBG;AAAjB,AACE,AAAMhC,AAAExL,AAAEuN;;AACV,AAAMvH,AAAEhG,AAAE,AAAGmC,AAAEqL;;AACf,AAAO,AAAA,AAAKxN;AAAG,AAAGmC,AAAEqL;AAAK,AAAChB,AAAKQ;;;;;;AAHjC;;;;AAIF,AAAMlJ,AAAQ9D,AAAE,AAAA,AAACiE,AAAiBuH;;AAClC,AAAMvG,AAASjF,AACT,AAAG,AAAMgG,AAAE,AAAA,AAAK,AAAA,AAAMA,AACnB,AAAA,AAAI,AAAA,AAAMhG,AAAG,AAAMiF,AAAS,AAAA,AAAKjF;;AAC1C,AAAA,AAAMiF,AAAY,AAAA,AAAKjF;;AACvB,AAAO,AAAA,AAAKA;AAAG,AAACwM,AAAKT;;;;;AAfzB;;;;AAgBF,AAAA,AAAMjI,AAAWmB;;AACjB,AAAM,AAAOoG,AAAoBD;;AACjC,AAAA,AAAOU;;AA9BX,AAiCE,AAAMY,AAAU,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACVC,AAAU,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACVc,AAAU,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACVC,AAAU,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACV5B,AAAU,AAAA,AAAC7H,AAAiByI;AAC5BE,AAAU,AAAA,AAAC3I,AAAiB0I;AALlC,AAME,AAAA,AAAO3M;AACA+L,AAAG,AAAA,AAACC,AACc,AAACC,AAAO,AAACY,AAAU5B,AAAGtH,AAAMuH,AACpB,AAAC2B,AAAU1B,AAAGxH,AAAMyH;;AAHrD,AAIE,AAAAc,AAAA,AAAAC,AAAmBJ;AAAnB,AAAA,AAAAG;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAA,AAAAG,AAAAD,AAAaE;AAAb,AACE,AAAMd,AAAE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACFxF,AAAE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AADR,AAEE,AAAA,AAAMwF,AAAKxF;;AACX,AAAA,AAAMA,AAAK,AAAC3C,AAAMiJ;;AAClB,AAAA,AAAOtM;AAAP,AAAWmC;AAAI6K,AAAI,AAACb,AAAIG;;AAAxB,AACE,AAAAJ,AAAA,AAAAC,AAAsBa;AAAtB,AAAA,AAAAd;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAAyB,AAAA,AAAAtB,AAAAD;AAAA,AAAAkB,AAAAK,AAAA,AAAA,AAAcJ;AAAd,AAAAD,AAAAK,AAAA,AAAA,AAAiBH;AAAjB,AACE,AAAMhC,AAAExL,AAAEuN;;AACV,AAAMvH,AAAEhG,AAAE,AAAGmC,AAAEqL;;AACf,AAAO,AAAA,AAAKxN;AAAG,AAAGmC,AAAEqL;AAAK,AAAChB,AAAKQ;;;;;;AAHjC;;;;AAIF,AAAI,AAAK,AAAA,AAAGhN,AAAM,AAAG,AAAG,AAAA,AAAGA,AAAM,AAACqD,AAAMiJ,AAAQb;AAC9C,AAAMmC,AAAI,AAAG,AAAG,AAAA,AAAG5N,AAAM,AAACqD,AAAMiJ,AAAQb;AAClCoC,AAAI,AAAA,AAAK,AAAA,AAAM7H;AACf8H,AAAI,AAAI,AAAA,AAAIF,AACN,AAAM5H,AAAE6H,AACR,AAAG,AAAM7H,AAAE6H,AAAI,AAAM7H,AAAE,AAAG6H,AAAGD;AAJzC,AAKE,AAAM,AAAOvC,AACP,AAAG,AAAOA,AAAoByC;;AAPxC;;AAQA,AAAMhK,AAAS,AAAI,AAAA,AAAG9D,AAAM0M,AAASC;AAC/B1H,AAAS,AAAI,AAAA,AAAGjF,AAAMyN,AAAUC;AAChC1N,AAAS,AAAA,AAACyE,AAAIzE;AAFpB,AAGE,AAAM8D,AAAQ9D,AAAE,AAAA,AAACiE,AAAiBuH;;AAClC,AAAMvG,AAASjF,AACT,AAAG,AAAMgG,AAAE,AAAA,AAAK,AAAA,AAAMA,AACnB,AAAA,AAAI,AAAA,AAAMhG,AAAG,AAAMiF,AAAS,AAAA,AAAKjF;;AAC1C,AAAA,AAAMiF,AAAY,AAAA,AAAKjF;;AACzB,AAAO,AAAA,AAAKA;AAAG,AAACwM,AAAKT;;;;;AA1BzB;;;;AA2BF,AAAA,AAAMW,AAAYe;;AAClB,AAAA,AAAMd,AAAYe;;AAClB,AAAO5B,AAAOc;;;;;;AAExB,AAAA,AAAMmB,AACHpK,AAAMsH,AAAGC,AAAKC,AAAGC,AAAKC;AADzB,AAEE,AAAI,AAAA,AAAI1H;AACN,AAACqH,AAAiBC,AAAGC,AAAKC,AAAGC,AAAKC;;AAClC,AAAM4C,AAAG,AAACC,AAAWjD;AACfkD,AAAG,AAACC,AAAYjD;AAChBkD,AAAM,AAAI,AAAClK,AAAS8G,AACZ,AAAM3J,AAAE,AAACmD,AAAIyG,AAAK,AAAA,AAAkBvH;AAApC,AACE,AAAI,AAAA,AAAOrC;AAAG,AAAA,AAAkBqC;;AAAOrC;;AACzC,AAAM8C,AAAK,AAACC,AAAY4G;AAClBjL,AAAK,AAAA,AAAK,AAAA,AAAMoE;AADtB,AAEE,AAAI,AAAA,AAAOpE;AACT,AAAA,AAAMoE;;AACN,AAAG,AAAMA,AAAKpE,AAAG,AAAMoE,AAAK,AAAA,AAAKpE;;;AAC7CsO,AAAM,AAAI,AAACnK,AAASgH,AACZ,AAAM7J,AAAE,AAACmD,AAAI2G,AAAK,AAAA,AAAkBzH;AAApC,AACE,AAAI,AAAA,AAAOrC;AAAG,AAAA,AAAkBqC;;AAAOrC;;AACzC,AAAA,AAAM,AAAC+C,AAAY8G;AAC3BoD,AAAwB,AAAAC,AAAA;AAd9BR,AAesB,AAAAW,AAAS,AAAA,AAAGhL;AAAZiL,AAAqBX;AAArBY,AAAwBR;AAAxBS,AAA8BX;AAA9BY,AAAiCT;AAAjCU,AACST;AADT,AAAA,AAAAI,AAAAC,AAAAC,AAAAC,AAAAC,AAAAC,AAAAL,AAAAC,AAAAC,AAAAC,AAAAC,AAAAC,AAACjB,AAAAA,AAAAA;;AAfvB,AAAAT,AAAAU,AAAA,AAAA,AAeOS;AAfP,AAAAnB,AAAAU,AAAA,AAAA,AAecU;AAERZ,AAAE,AAAOS;AAjBf,AAkBE,AAAM,AAAOlD,AAAoB,AAAG,AAAOA,AAAoByC;;AAC/D,AAACV,AAAUzJ,AACA,AAAI,AAAYsK,AAAGQ,AACjBxD,AACA,AAACgE,AAAwBtL,AAAMsH,AAAGwD,AAAOX,AAC3C,AAAG5C,AAAK4C,AACR,AAAIY,AACF,AAAI,AAAYP,AAAGO,AACjBvD,AACA,AAAC+D,AAAuBvL,AAAMwH,AAAGC,AAAKsD,AAAOZ,AAC/C,AAACqB,AAAsBxL,AAAMwH,AAC/B,AAAGC,AAAK0C,AACRzC;;;AAEjB,AAAA,AAAM+D,AAAczL,AAAMsH,AAAGC,AAAKC,AAAGC;AAArC,AACE,AAAMiE,AAAM,AAAOpE;AACbqE,AAAM,AAAOnE;AACboE,AAAM,AAACjF,AAAa+E;AACpBG,AAAM,AAAClF,AAAagF;AACpBG,AAAM,AAACxD,AAAO,AAAClB,AAAKwE,AAAIF,AAAM,AAACtE,AAAKyE,AAAIF;AAJ9C,AAKE,AAAI,AAAA,AAAG,AAACjM,AAAMoM;AACZ,AAAOxE,AAAGE;;AACV,AAAMlG,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTnB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACT4L,AAAS,AAAC3E,AAAKwE,AAAI,AAAI,AAACpL,AAAS8G,AACZ,AAACwB,AAAe9I,AAAMuH,AACtB,AAAC7G,AAAY4G;AAClC0E,AAAS,AAAC5E,AAAKyE,AAAI,AAAI,AAACrL,AAASgH,AACZ,AAACsB,AAAe9I,AAAMyH,AACtB,AAAC/G,AAAY8G;AAClCwE,AAAS,AAAM3J,AAAE,AAAC4J,AAAKF;AAAd,AACE,AAAA,AAAAG,AAAC5C;AAAD,AAAM,AAAA4C,AAAK7J;AAAG2J;;AACzBvL,AAAS,AAAC6H,AAAOyD,AAAMC;AAV7B,AAWE,AAAA,AAAM7L,AAAWmB;;AACjB,AAAA,AAAOjF;AAAIwK,AAAG,AAAC2B,AAAIsD;;AAAnB,AACE,AAAMjF;AAAN,AACE,AAAM1G,AAAQ9D,AAAE,AAACqM,AAAM7B;;AACvB,AAAO,AAAA,AAAKxK;AAAG,AAACwM,AAAKhC;;;;;AAFvB;;;;AAGF,AAAA,AAAOxK;AAAIoE,AAAK,AAAC+H,AAAI/H;;AAArB,AACE,AAAIA;AACF,AAAI,AAAMa,AAASjF,AAAE,AAACqM,AAAMjI;;AACxB,AAAO,AAAA,AAAKpE;AAAG,AAACwM,AAAKpI;;;;;AACzB,AAAA,AAAMa,AAAYjF;;;;;AACtB,AAAA,AAAO,AAAA,AAACiE,AAAiBH;;;AAEjC,AAAKgM,AAA6B,AAAA,AAAA,AAAA,AAACC;AACnC,AAAKC,AAA4B,AAAA,AAACD;AAYlC,AAAA,AAAME,AAAatP;AAAnB,AACO,AAAOA,AACP,AAACuP,AAAW,AAACC,AAAWC,AACxB,AAAA,AAACrF;;AAWR,AAAA,AAAMsF,AAAuBC;AAA7B,AACOA,AACA,AAACxF,AAAOmF,AACR,AAAA,AAAClF;;AAcR,AAAA,AAAMwF,AAAkB1M;AAAxB,AACE,AAAO7D,AAAE,AAAA,AAAK,AAAS6D;;AAAvB,AACE,AAAI,AAAA,AAAM7D;AACRA;;AACA,AAAI,AAAA,AAAM,AAAM6D,AAAI7D;AAClB,AAAO,AAAA,AAAKA;;;;AACZA;;;;;;AAER,AAAA,AAAMwQ,AAA+B7P,AAAKgD;AAA1C,AACE,AAAI,AAACQ,AAASxD;AACZ,AAAOA,AAAKA;AACLgD,AAAMA;AADb,AAEO8M;;AAFP,AAGE,AAAI,AAAA,AAAO9M;AACT,AAAI,AAAA,AAAMhD;AACR8P;;AAEA,AAAA,AAAGA;;;AACL,AAAM5M,AAAI,AAAOlD;AACX+P,AAAc,AAACH,AAAiB1M;AAChC8M,AAAwB,AAAA,AAAkBhN;AAFhD,AAGE,AAAI,AAAA,AAAG+M;AACLD;;AACA,AAAO,AAAM5M,AAAI6M;AACV,AAAA,AAAG/M;AACH,AAAG8M,AAAI,AAAGC,AAAcC;;;;;;;;;;AAEvC,AAAMvM,AAAK,AAACC,AAAY1D;AAAxB,AACE,AAAMyD,AAAK,AAAA,AAAK,AAAA,AAAMA;;;AAE5B,AAAA,AAAMwM,AAAwB7Q;AAA9B,AACE,AAAA,AAAA4I,AAAMkI,AAAQf;AAAd,AACE,AAAI,AAAA,AAAI,AAAS/P;AAOfA;;AACA,AAAMyG,AAAK,AAAQzG;AACbuQ,AAAS,AAACL,AAAYzJ;AACtBsK,AAAc,AAACT,AAAsBC;AACrCS,AAAyB,AAAC1N,AAAMyN;AAChCE,AAAoB,AAAA,AAAGD;AAJ7B,AAKE,AAAIC;AAIFjR;;AAGA,AAAM+D,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTmB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTsC,AAAS,AAACtD,AAAa,AAAQuC,AAAM1C;AACrCH,AAAS,AAAS5D;AAClBkR,AAAiB,AAAGtN,AAAM,AAAA,AAAA;AAJhC,AAKE,AAACuN,AAAMlB,AAA4BmB;;AACnC,AAAA,AAAOpK;AACAqK,AAAaN;AADpB,AAEOO;;AAFP,AAGE,AAAA3G,AAAsB,AAACyB,AAAIiF;AAA3B,AAAA,AAAA1G;AAAA,AAAAA,AAAS0G;AAAT,AACE,AAAME,AAAW,AAACjF,AAAM+E;AAClBG,AAA0B,AAACf,AACAc,AAAWL;AACtCO,AAAc,AAAGH,AAASE;AAHhC,AAIE,AAAMzN,AAAQiD,AAAIuK;;AAClB,AAAMrM,AAAS8B,AAAIyK;;AACnB,AAAO,AAAA,AAAKzK;AAAK,AAAC0K,AAAKL;AAAcI;;;;;;AAPzC;;;;AAQF,AAAA,AAAMvM,AAAY8L;;AAClB,AAAA,AAAMjN,AAAWmB;;AACjB,AAAMyM,AAAM,AAAArL,AAAA,AAAS,AAAOtG,AAAG,AAAA,AAAG4D,AACb4D,AAAS,AAAQxH,AAAG,AAAQA;AADjD,AAEE,AAAM,AAAA,AAAW8Q;AAAjB,AACE,AAAAc,AAAC,AAAA,AAAWd;AAAZ,AAAA,AAAAc,AAAAA,AAAAA,AAAoB5R,AAAAA,AAAE2R,AAAAA;;AADxB;;AAEAA;;;;AAMd,AAAA,AAAKE;AAUL,AAAA,AAAMC,AAAkB9R;AAAxB,AACE,AAAA,AAAG,AAASA;;AAad,AAAA,AAAM+R,AAAiB/R;AAAvB,AACE,AAAM+G,AAAS,AAACtH,AAAaO;AAA7B,AACE,AAAI,AAAA,AAAO+G;AAAX;;AAEE,AAAMiL,AAAa,AAAA,AAAG,AAAShS;AACzBiS,AAA6B,AAAA,AAAkBD;AADrD,AAEE,AAAGjL,AAASkL;;;AAWpB,AAAKC,AAAgB,AAAA,AAAA,AAAA,AAAClC;AACtB,AAAKmC,AAA+B,AAAA,AAACnC;AACrC,AAAKoC,AAA+B,AAAA,AAACpC;AAErC,AAAA,AAAMqC,AAAmCC,AAAGC,AAAGC;AAA/C,AACE,AAAA,AAAA5J,AAAMkI,AAAQoB;AAAd,AACE,AAAI,AAAI,AAACJ,AAAiBU,AAClB,AAACT,AAAgBS;AACvB,AACE;AAGA,AAAI,AAACT,AAAgBO;AAEnB,AACE,AAACnB,AAAMgB,AAA+Bf;;AACtC;AAIA,AAAMqB,AAAsB,AAACjJ,AAAM8I,AAAI,AAACI,AAAKJ,AAAI,AAACI,AAAKH;AAAvD,AACE,AAAM,AAAA,AAAWzB;AAAjB,AACE,AAAA6B,AAAC,AAAA,AAAW7B;AAAZ,AAAA,AAAA6B,AAAAA,AAAAA,AAAoBH,AAAAA,AAAcC,AAAAA;;AADpC;;AAEAA;;AAMJ,AAAMA,AAAkB,AAACC,AAAKJ,AAAGC;AAAjC,AACE,AAACpB,AAAMiB,AAA+BhB;;AACtC,AAAM,AAAA,AAAWN;AAAjB,AACE,AAAA8B,AAAC,AAAA,AAAW9B;AAAZ,AAAA,AAAA8B,AAAAA,AAAAA,AAAoBJ,AAAAA,AAAcC,AAAAA;;AADpC;;AAEAA;;;AAEND;;;AAEN,AAAA,AAAMK,AAAmBP,AAAGC;AAA5B,AACE,AACE,AAAA,AAAO,AAACjP,AAAMgP;AAAKC;;AADrB,AAEE,AAAG,AAAG,AAACjP,AAAMgP,AAAI,AAAChP,AAAMiP,AAAKV;AAC7B,AAAM3D,AAAG,AAAC5K,AAAMgP;AAAKlE,AAAG,AAAC9K,AAAMiP;AAA/B,AACE,AAAO,AAAA7O,AACC,AAAA,AAAA,AAAA,AAAA,AAAA,AAC+B,AAAGwK,AAAGE,AAEhCyD;;AARjB,AASE,AAAG,AAACvO,AAAMiP,AAAInT,AAAA;AAAuB,AAACsT,AAAKJ,AAAGC;;AAThD,AAWE,AAAMS,AAAG,AAASV;AACZW,AAAG,AAASV;AACZW,AAAG,AAAQZ;AACXa,AAAG,AAAC5L,AAAU2L,AAAGF,AAAG,AAAG,AAAC1P,AAAMgP,AAAI,AAAA,AAAM,AAAS,AAAQA;AACzDY,AAAG,AAAIC,AACF,AAAMzM,AAAU,AAAQ4L;AAClBhL,AAAU,AAAA,AAACpD,AAAiBwC;AAC5BvC,AAAU,AAAK,AAACC,AAAS8O,AAAI,AAAA,AAAI,AAASxM;AAC1C5C,AAAU,AAAAE,AAAY,AAAA,AAAA,AAAIG;AAHhC,AAIE,AAAA,AAAML,AAAMoP;;AACZ,AAAA,AAAMpP,AAAM,AAACsP,AAAUJ,AAAG1L;;AAC1B,AAAA,AAAQnD;AACN,AAAME,AAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAX,AACE,AAAA,AAAA,AAAMA;;AACN,AAAA,AAAMA,AAAO,AAAG,AAACf,AAAMgP,AAAI,AAAS5L;;AACpC,AAAA,AAAMrC,AAAO,AAACf,AAAMgP;;AACpB,AAAA,AAAMxO,AAAOO;;AALjB;;AAMA,AAAA,AAACH,AAAiBJ;AACpB,AAACuP,AAAUH,AAAGF,AACH,AAACvT,AAAa6S,AACd,AAAQA;AACxBU,AAAG,AAAIG,AAAG,AAAA,AAAGH,AAAMA;AACnBM,AAAG,AAAQf;AACX5Q,AAAG,AAAA4R,AAAKP;AAALQ,AAAQP;AAAR,AAAA,AAAAM,AAAAC,AAAAD,AAAAC;;AACHN,AAAG,AAAClJ,AAAckJ,AAAGF,AAAGrR;AACxB2R,AAAG,AAACtJ,AAAcsJ,AAAGL,AAAGtR;AACxB2J,AAAmB,AAAAmD,AAAA;AA1BzBqE,AA2Bc,AAAC9E,AAAQrM,AACAuR,AAAG,AAAC5P,AAAMgP,AACVgB,AAAG,AAAG,AAAChQ,AAAMiP,AAAI,AAAS,AAAQA,AAClCjH;AA9BvB,AAAAiC,AAAAuF,AAAA,AAAA,AA2BO5H;AA3BP,AAAAqC,AAAAuF,AAAA,AAAA,AA2BU1H;AAIJ2C,AAAE,AAAOzC;AACTmI,AAAQ,AAAG,AAACnQ,AAAMgP,AAAIvE;AACtB2F,AAAQ,AAAA,AAAG,AAACpQ,AAAMiP,AAAI,AAAS,AAAQA,AAAKxE;AAjClDgF,AAkCc,AAAI,AAAY3H,AAAGkI,AACjB,AAACjE,AAAa1N,AAAEuJ,AAAGuI,AAAMrI,AAAGsI,AAC5B,AAAOxI,AAAGE;AApC1B,AAAAmC,AAAAwF,AAAA,AAAA,AAkCO7H;AAlCP,AAAAqC,AAAAwF,AAAA,AAAA,AAkCU3H;AAGJqI,AAAQ,AAAIrI,AACFqI,AACA,AAAGA,AAAMC;AACnBA,AAAQ,AAAA,AAAItI,AACFsI;AAzChB,AA2CE,AAAItI;AACF,AAAMtH,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACT0D,AAAS,AAAA,AAACtD,AAAiBJ;AADjC,AAEE,AAAA,AAAMA,AAAMoH;;AACZ,AAAA,AAAMpH,AAAMsH;;AACZ,AAAA,AAAMtH,AAAO,AAAA6P,AAAM,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAN,AAAA,AAAAA,AAAA,AACUF;;AADV,AAAAE,AAAA,AAEU,AAAGF,AAAMC;;AAFnB,AAAAC,AAAA,AAAA;;AAAAA;;;AAIb,AAAArN,AAAA,AAAA,AAAS,AAAG,AAAChD,AAAMgP,AAAI,AAAChP,AAAMiP,AAAK,AAAA,AAAG5Q,AAAK6F,AAAS,AAAQ+K;;AAE9D,AAAOtM,AAAEiF;AACFvJ,AAAEA;;AADT,AAEE,AAAI,AAAK,AAAA,AAAGA,AACH,AAAA,AAAM,AAAA,AAAM,AAAOsE;AAC1B,AAAO,AAAA,AAAM,AAAOA;AAAM,AAAA,AAAGtE;;;;;AAC7B,AAAA2E,AAAA,AAAA,AAAS,AAAG,AAAChD,AAAMgP,AAAI,AAAChP,AAAMiP,AAAK5Q,AAAEsE,AAAE,AAAQsM;;;;;;;;;;AAG3D,AAAA,AAAM3I,AAAc0I,AAAGC;AAAvB,AACE,AAAMW,AAAG,AAACL,AAAkBP,AAAGC;AACzBe,AAAG,AAACzC,AAAuBqC;AADjC,AAEE,AAACb,AAAkCC,AAAGC,AAAGe;;AAE7C,AAAA;;;;;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASM,AAME1S,AAAKkB;;AANhB,AAAA,AAAA,AAMWlB;AANX,AAOI,AAAI,AAAiBuF;AACnB,AAAI,AAAA,AAAGoN;AACL,AAAI,AAAMnN,AAAKmN,AAAKzR;;AAChB,AAAMoE,AAAK,AAAA,AAAKA;;AAChB,AAAMqN,AAAK,AAAA,AAAKA;;AAChB3S;;AACJ,AAAMoG,AAAU,AAACpD,AAAa,AAAQuC,AAAMC;AACtCW,AAAU,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AADhB,AAEE,AAAA,AAAMA,AAAWjF;;AACjB,AAAMsE,AAAKW;;AACX,AAAA,AAAMwM;;AACN,AAAI,AAACtM,AAAUd,AAAK7C,AAAM4C;AACxB,AAAI,AAACpC,AAASqC;AACZ,AAAM1C,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAd,AACE,AAAA+P,AAAM/P;AAAN,AAAA,AAAA+P,AAAA,AACUrN;;AADV,AAAAqN,AAAA,AAEU,AAACpM,AAAShB,AAAK,AAAQD,AAAM7C,AAAM0D;;AAF7CwM;AAGA,AAAMrN,AAAM,AAACvC,AAAa,AAAQuC,AAAM1C;;AACxC,AAAMH,AAAM,AAAA,AAAGA;;AACf,AAAM4C,AAAM,AAAA,AAAKA;;AACjBtF;;AACF,AAAM6C,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTmB,AAAS,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACTsC,AAAS,AAACtD,AAAa,AAAQuC,AAAM1C;AACrC4D,AAAiB,AAAA,AAAM,AAACrD,AAAYmC;AAH1C,AAIE,AAAAsN,AAAMhQ;AAAN,AAAA,AAAAgQ,AAAA,AACWtN;;AADX,AAAAsN,AAAA,AAEW,AAACrM,AAAShB,AAAK,AAAQD,AAAM7C,AAAM0D;;AAF9C,AAAAyM,AAAA,AAGW7O;;AAHX6O;AAIA,AAAAC,AAAM9O;AAAN,AAAA,AAAA8O,AAAA,AACWrM;;AADX,AAAAqM,AAAA,AAEW,AAAA,AAAGrM;;AAFd,AAAAqM,AAAA,AAAA;;AAAAA;AAIA,AAAMvN,AAAMe;;AACZ,AAAM5D,AAAM,AAAA,AAAGA;;AACf,AAAM4C,AAAM,AAAA,AAAKA;;AACjBtF;;;AACJ,AAAMsG,AAAS,AAACyM,AAAWrQ,AAAM4C,AAAI,AAAQC,AAAMA,AAAKa;AAAxD,AACE,AAAMb,AAAKe;;AACX,AAAMhB,AAAK,AAAA,AAAKA;;AAChBtF;;;;AACR,AAAO,AAAAwC,AAAA;;;;AAhDb,AAAA,AAAA,AAAA,AAASkQ,AAkDQ1S;;AAlDjB,AAAA,AAAA,AAkDiBA;AAlDjB,AAmDI,AAAI,AAAiBuF;AACnB,AAAI,AAAA,AAAM,AAAQA;;AACd,AAAMyN,AAAa,AAAAlQ,AAAY6P;AAA/B,AACE,AAAA,AAAA,AAAC5P,AAAWyC,AAAOwN,AAAeL;;AAClC,AAAAvN,AAAA,AAAA,AAASE,AAAI5C,AAAM6C,AAAKyN;;AAC9B,AAAO,AAAAxQ,AAAA;;;;AAxDb,AAAA,AAAA,AAAA,AAASkQ,AA2DG1S,AAAKiT,AAAIhN;;AA3DrB,AAAA,AAAA,AA2DYjG;AA3DZ,AA4DI,AAAWA,AAAKiT,AAAIhN;;;AA5DxB,AAAA,AAAA,AAAA,AAASyM,AA+DK1S,AAAKjB,AAAEkH;;AA/DrB,AAAA,AAAA,AA+DcjG;AA/Dd,AAgEI,AAAI,AAAiBuF;AACnB,AACE,AAAK,AAAA,AAAMxG,AAAG,AAAGA,AAAEuG;AACnB,AAAMO,AAAS,AAAGP,AAAIqN;AAAtB,AACE,AAAI,AAAI9M,AAAS9G;AACf,AAAMyG,AAAK,AAAGzG,AAAE8G,AAAUI;;AAC1B,AAAMV,AAAK,AAAC2N,AAAUxQ,AAAM,AAAQ6C,AAAMA,AAAKxG,AAAEkH;;;AACnDjG;;AANJ,AAQE,AAAIjB,AAAEuG;AAAK,AAAQtF,AAAKiG;;AAR1B,AAUQ,AAACF,AAA2BhH,AAAEuG;;;;;AACtC,AAAO,AAAA9C,AAAA;;;;AA5Eb,AAAA,AAAA,AAAA,AAASkQ,AA8EC1S;;AA9EV,AAAA,AAAA,AA8EUA;AA9EV,AA+EI,AAAI,AAAiBuF;AACnB,AACE,AAAA,AAAOD;AACP,AAAO,AAAA9C,AAAA;;AAFT,AAIE,AAAA,AAAM8C;AACN,AAAI,AAAA,AAAMA;;AACN,AAAA,AAAMqN;;AACN,AAAA,AAAA,AAAMnN;;AACNxF;;AARN,AAUE,AAAA,AAAG2S;AACH,AAAI,AAAMrN,AAAK,AAAA,AAAKA;;AAChB,AAAMqN,AAAK,AAAA,AAAKA;;AAChB,AAAA,AAAMnN,AAAKmN;;AACX3S;;AAdN,AAiBE,AAAMmT,AAAc,AAAYnT,AAAK,AAAA,AAAGsF;AAClCa,AAAc,AAACiC,AAAc+K;AAC7BC,AAAc,AAASD;AACvB7M,AAAc,AAAC+M,AAAU3Q,AAAM4C,AAAI,AAAQC,AAAMA;AAHvD,AAIE,AACE,AAAA,AAAMe;AACN,AAAI,AAAMhB,AAAK,AAAA,AAAKA;;AAChB,AAAMC,AAAK,AAAC+N,AAAgB,AAAQ/N,AAAM0B;;AAC1C,AAAMzB,AAAKW;;AACX,AAAMwM,AAAKS;;AACXpT;;AANN,AAQE,AAAK,AAAA,AAAG0C,AACH,AAAA,AAAM,AAAA,AAAM,AAAO4D;AACxB,AAAI,AAAMhB,AAAM,AAAA,AAAKA;;AACjB,AAAM5C,AAAM,AAAA,AAAGA;;AACf,AAAM6C,AAAM,AAAC+N,AAAgB,AAAQ/N,AACR,AAAA,AAAM,AAAOe;;AAC1C,AAAMd,AAAMW;;AACZ,AAAMwM,AAAMS;;AACZpT;;AAhBN,AAmBE,AAAI,AAAMsF,AAAK,AAAA,AAAKA;;AAChB,AAAMC,AAAKe;;AACX,AAAMd,AAAKW;;AACX,AAAMwM,AAAKS;;AACXpT;;;;;;;;;AACV,AAAO,AAAAwC,AAAA;;;;AA7Hb,AAAA,AAAA,AAAA,AAASkQ,AAgIE1S;;AAhIX,AAAA,AAAA,AAgIWA;AAhIX,AAiII,AAAI,AAAiBuF;AACnBD;;AACA,AAAO,AAAA9C,AAAA;;;;AAnIb,AAAA,AAAA,AAAAwC,AAAS0N;;AAAT,AAAA,AAAA,AAAA,AAASA,AAsIQ1S;;AAtIjB,AAAA,AAAA,AAsIiBA;AAtIjB,AAuII,AAAGsF,AAAIqN;;;AAvIX,AAAA,AAAA,AAAA,AAASD,AAyIM1S,AAAKjB;;AAzIpB,AAAA,AAAA,AAyIeiB;AAzIf,AA0II,AAAI,AAAK,AAAA,AAAMjB,AAAG,AAAGA,AAAEuG;AACrB,AAAI,AAAIvG,AAAE,AAAciB;AACtBwF;;AACA,AAAOzG,AAAEA;AAAEW,AAAK6F;AAAK7C,AAAMA;;AAA3B,AACE,AAAI,AAAA,AAAOA;AACT,AAAOhD;;AACP,AAAI,AAACwD,AAASxD;AACZ,AAAOA,AAAM,AAAM,AAAOA,AACP,AAAA,AAAS,AAAiBX,AAAE2D;AACxCA,AAAM,AAAA,AAAGA;;AAFhB,AAGE,AAAI,AAAA,AAAOA;AACT,AAAOhD;;AACP,AAAO,AAAM,AAAOA,AACP,AAAA,AAAS,AAAiBX,AAAE2D;AAClC,AAAA,AAAGA;;;;;;;;AACd,AAAMS,AAAK,AAACC,AAAY1D;AAClB2D,AAAK,AAAOA,AAAE,AAAA,AAAS,AAAiBtE,AAAE2D;;AAArC,AACE,AAAI,AAAG3D,AAAE,AAAMoE,AAAKE;AAClBA;;AACA,AAAO,AAAA,AAAKA;;;;;;;AACrBtE,AAAK,AAAI,AAAA,AAAMsE,AACR,AAAGtE,AAAE,AAAMoE,AAAK,AAAA,AAAKE,AACrBtE;AAPb,AAQE,AAAOA;AACA,AAAM,AAAOW,AAAM2D;AACnB,AAAA,AAAGX;;;;;;;;;;;AACpB,AAACqD,AAA2BhH,AAAEuG;;;;AApKpC,AAAA,AAAA,AAASoN;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAvT,AAAAC,AAAAC,AAASqT;AAAT,AAAA,AAAApT,AAAAF,AAAA;;;AAAA;;;AAAA,AAAS8I,AAAqB5C,AACA5C,AACA6C,AACAC,AACAmN;AAJ9B,AAAA,AAAAD,AAA8BpN,AACA5C,AACA6C,AACAC,AACAmN;;;AAJrBD","names",["clojure.core.rrb-vector.rrbt/rrbt-concat-threshold","clojure.core.rrb-vector.rrbt/max-extra-search-steps","clojure$core$rrb-vector$rrbt$IVecImpl$_tail_offset$dyn","x__4428__auto__","m__4429__auto__","clojure.core.rrb-vector.rrbt/-tail-offset","goog/typeOf","m__4426__auto__","cljs.core/missing-protocol","clojure$core$rrb-vector$rrbt$IVecImpl$_array_for$dyn","clojure.core.rrb-vector.rrbt/-array-for","clojure.core.rrb-vector.rrbt/IVecImpl","v","i","clojure$core$rrb-vector$rrbt$AsRRBT$_as_rrbt$dyn","clojure.core.rrb-vector.rrbt/-as-rrbt","clojure.core.rrb-vector.rrbt/AsRRBT","this__4369__auto__","writer__4370__auto__","opt__4371__auto__","cljs.core/-write","clojure.core.rrb-vector.rrbt/RRBChunkedSeq","clojure.core.rrb-vector.rrbt/->RRBChunkedSeq","vec","node","off","meta","__hash","coll","cljs.core/pr-str*","this","writer","opts","cljs.core/pr-sequential-writer","cljs.core/pr-writer","m","clojure.core.rrb-vector.rrbt/rrb-chunked-seq","other","cljs.core/equiv-sequential","s","G__32853","G__32854","G__32855","G__32856","G__32849","G__32850","G__32851","G__32852","o","cljs.core/cons","cljs.core/with-meta","cljs.core/List","cljs.core.array_chunk","l","cljs.core/-count","G__32857","G__32858","G__32859","G__32860","G__32861","G__32862","h__4238__auto__","cljs.core/hash-ordered-coll","f","cljs.core.ci_reduce","cljs.core.subvec","cljs.core/count","start","var_args","G__32864","js/Error","clojure.core.rrb-vector.rrbt/slice-right","shift","end","arr","new-arr","js/Array","cljs.core/array-copy","cljs.core/->VectorNode","reg?","clojure.core.rrb-vector.nodes/regular?","rngs","clojure.core.rrb-vector.nodes/node-ranges","j","child-end","ce","cljs.core/mod","new-child","G__32865","G__32866","G__32867","regular-child?","new-child-rng","clojure.core.rrb-vector.nodes/last-range","new-rngs","step","n__4613__auto__","clojure.core.rrb-vector.rrbt/slice-left","new-len","len","child-start","x__4217__auto__","y__4218__auto__","capped-end","G__32868","G__32869","G__32870","G__32871","rng0","r","cljs.core/PROTOCOL_SENTINEL","self__","args32872","cljs.core/aclone","clojure.core.rrb-vector.rrbt/Vector","clojure.core.rrb-vector.rrbt/->Vector","cnt","root","tail","that","cljs.core.array_seq","clojure.core.rrb_vector.rrbt.rrb_chunked_seq","_","tail-off","idx","cljs.core/vector-index-out-of-bounds","not-found","val","tail-len","new-tail","tail-node","clojure.core.rrb-vector.nodes/overflow?","new-root","G__32884","clojure.core.rrb-vector.trees/new-path","root-total-range","G__32885","G__32886","clojure.core.rrb-vector.trees/push-tail","cljs.core/PersistentVector","cljs.core/-with-meta","root-cnt","clojure.core.rrb-vector.trees/pop-tail","clojure.core.rrb-vector.nodes/empty-node","clojure.core.rrb-vector.trees/do-assoc","cljs.core/RSeq","k","init","lim","G__32876","G__32877","G__32878","cljs.core/deref","cljs.core/reduced?","cljs.core.compare_indexed","G__32879","G__32880","G__32881","G__32882","G__32883","clojure.core.rrb-vector.rrbt/->Transient","clojure.core.rrb-vector.transients/editable-root","clojure.core.rrb-vector.transients/editable-tail","new-cnt","cljs.core/empty","tail-cut?","G__32887","G__32888","clojure.core.rrb-vector.rrbt/splice-rrbts","cljs.core/meta","cljs.core/Subvec","clojure.core.rrb-vector.protocols/-slicev","clojure.core.rrb-vector.rrbt/shift-from-to","from","to","G__32889","G__32890","G__32891","clojure.core.rrb-vector.rrbt/slot-count","clojure.core.rrb-vector.nodes/index-of-nil","clojure.core.rrb-vector.rrbt/subtree-branch-count","cs","sbc","temp__5733__auto__","child","clojure.core.rrb-vector.rrbt/leaf-seq","p1__32892#","cljs.core.mapcat","cljs.core.take","clojure.core.rrb-vector.rrbt/rebalance-leaves","n1","cnt1","n2","cnt2","transferred-leaves","slc1","slc2","a","sbc1","sbc2","p","e","cljs.core/quot","new-n1","bs","cljs.core.partition_all","cljs.core.concat","temp__5735__auto__","cljs.core/seq","xs__6292__auto__","cljs.core/first","block","xs","cljs.core/next","clojure.core.rrb-vector.nodes/regular-ranges","new-arr1","new-arr2","new-n2","clojure.core.rrb-vector.rrbt/child-seq","cseq","c","gcs","cljs.core.map","cljs.core/list","cljs.core/-","clojure.core.rrb-vector.rrbt/rebalance","vec__32893","cljs.core.nth","gc","gcr","new-rngs1","new-rngs2","vec__32896","tbs","li","d","clojure.core.rrb-vector.rrbt/zippath","vec__32899","c1","clojure.core.rrb-vector.nodes/last-child","c2","clojure.core.rrb-vector.nodes/first-child","ccnt1","ccnt2","next-transferred-leaves","cljs.core/Box","new-c1","new-c2","G__32902","G__32903","G__32904","G__32905","G__32906","G__32907","clojure.core.rrb-vector.nodes/replace-rightmost-child","clojure.core.rrb-vector.nodes/replace-leftmost-child","clojure.core.rrb-vector.nodes/remove-leftmost-child","clojure.core.rrb-vector.rrbt/squash-nodes","arr1","arr2","li1","li2","slots","rngs1","rngs2","cljs.core/last","p1__32908#","clojure.core.rrb-vector.rrbt/peephole-optimization-config","cljs.core.atom","clojure.core.rrb-vector.rrbt/peephole-optimization-count","clojure.core.rrb-vector.rrbt/child-nodes","cljs.core.take_while","cljs.core/complement","cljs.core/nil?","clojure.core.rrb-vector.rrbt/bounded-grandchildren","children","clojure.core.rrb-vector.rrbt/last-non-nil-idx","clojure.core.rrb-vector.rrbt/count-vector-elements-beneath","acc","max-child-idx","num-elems-in-full-child","clojure.core.rrb-vector.rrbt/peephole-optimize-root","config","grandchildren","num-granchildren-bounded","many-grandchildren?","grandchild-shift","cljs.core.swap_BANG_","cljs.core/inc","remaining-gc","elem-sum","grandchild","num-elems-this-grandchild","next-elem-sum","cljs.core/rest","new-v","fexpr__32909","clojure.core.rrb-vector.rrbt/max-vector-elements","clojure.core.rrb-vector.rrbt/shift-too-large?","clojure.core.rrb-vector.rrbt/poor-branching?","shift-amount","max-capacity-divided-by-1024","clojure.core.rrb-vector.rrbt/fallback-config","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count1","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count2","clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-if-needed","v1","v2","splice-result","new-splice-result","cljs.core.into","fexpr__32910","fexpr__32911","clojure.core.rrb-vector.rrbt/splice-rrbts-main","vec__32912","vec__32915","s1","s2","r1","o?","clojure.core.rrb-vector.nodes/new-path*","clojure.core.rrb-vector.nodes/fold-tail","r2","x__4214__auto__","y__4215__auto__","ncnt1","ncnt2","G__32918","clojure.core.rrb-vector.rrbt/Transient","tidx","G__32919","G__32920","G__32921","clojure.core.rrb-vector.transients/push-tail!","trimmed-tail","key","clojure.core.rrb-vector.transients/do-assoc!","new-tail-base","new-tidx","clojure.core.rrb-vector.transients/pop-tail!","clojure.core.rrb-vector.transients/ensure-editable"]],"~:used-vars",["^J",["~$clojure.core.rrb-vector.rrbt/slice-left","~$cljs.core/mapcat","~$clojure.core.rrb-vector.nodes/empty-node","~$cljs.core/PROTOCOL_SENTINEL","~$cljs.core/rest","~$clojure.core.rrb-vector.rrbt/leaf-seq","~$clojure.core.rrb-vector.nodes/overflow?","~$clojure.core.rrb-vector.rrbt/last-non-nil-idx","~$clojure.core.rrb-vector.rrbt/fallback-config","~$clojure.core.rrb-vector.rrbt/->Vector","~$cljs.core/ci-reduce","~$clojure.core.rrb-vector.rrbt/count-vector-elements-beneath","~$clojure.core.rrb-vector.rrbt/child-seq","~$clojure.core.rrb-vector.rrbt/squash-nodes","~$clojure.core.rrb-vector.rrbt/slice-right","~$cljs.core/pr-sequential-writer","~$clojure.core.rrb-vector.rrbt/-tail-offset","~$clojure.core.rrb-vector.rrbt/Transient","~$clojure.core.rrb-vector.rrbt/poor-branching?","~$cljs.core/take-while","~$clojure.core.rrb-vector.rrbt/rrbt-concat-threshold","~$cljs.core/-write","~$cljs.core/pr-writer","~$clojure.core.rrb-vector.transients/do-assoc!","~$clojure.core.rrb-vector.rrbt/rebalance","~$cljs.core/count","~$cljs.core/deref","~$cljs.core/-assoc-n!","~$clojure.core.rrb-vector.rrbt/->RRBChunkedSeq","~$cljs.core/take","~$cljs.core/aclone","~$clojure.core.rrb-vector.nodes/replace-rightmost-child","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-if-needed","~$cljs.core/atom","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count2","~$cljs.core/Subvec","~$cljs.core/-with-meta","~$cljs.core/pr-str*","~$clojure.core.rrb-vector.rrbt/AsRRBT","~$clojure.core.rrb-vector.nodes/last-range","~$clojure.core.rrb-vector.nodes/replace-leftmost-child","~$cljs.core/compare-indexed","~$clojure.core.rrb-vector.protocols/-slicev","~$clojure.core.rrb-vector.rrbt/splice-rrbts","~$clojure.core.rrb-vector.trees/push-tail","~$cljs.core/-","~$cljs.core/into","~$cljs.core/array-seq","~$cljs.core/array-chunk","~$cljs.core/-conj","~$cljs.core/with-meta","~$cljs.core/map","~$clojure.core.rrb-vector.transients/ensure-editable","~$cljs.core/-assoc-n","~$cljs.core/PersistentVector","~$cljs.core/List","~$cljs.core/empty","~$cljs.core/swap!","~$clojure.core.rrb-vector.rrbt/max-vector-elements","~$cljs.core/-chunked-next","~$cljs.core/equiv-sequential","~$clojure.core.rrb-vector.rrbt/shift-too-large?","~$clojure.core.rrb-vector.rrbt/peephole-optimization-count","~$clojure.core.rrb-vector.rrbt/splice-rrbts-main","~$clojure.core.rrb-vector.nodes/remove-leftmost-child","~$cljs.core/-nth","~$clojure.core.rrb-vector.rrbt/fallback-to-slow-splice-count1","~$clojure.core.rrb-vector.rrbt/->Transient","~$cljs.core/RSeq","~$clojure.core.rrb-vector.trees/new-path","~$clojure.core.rrb-vector.trees/do-assoc","~$clojure.core.rrb-vector.rrbt/shift-from-to","~$cljs.core/subvec","~$clojure.core.rrb-vector.rrbt/peephole-optimization-config","~$clojure.core.rrb-vector.nodes/regular?","~$cljs.core/reduced?","~$cljs.core/nil?","~$cljs.core/meta","~$clojure.core.rrb-vector.rrbt/zippath","~$clojure.core.rrb-vector.rrbt/rrb-chunked-seq","~$clojure.core.rrb-vector.rrbt/slot-count","~$cljs.core/next","~$cljs.core/->VectorNode","~$clojure.core.rrb-vector.rrbt/child-nodes","~$clojure.core.rrb-vector.rrbt/subtree-branch-count","~$clojure.core.rrb-vector.rrbt/-array-for","~$cljs.core/not","~$cljs.core/complement","~$clojure.core.rrb-vector.rrbt/-as-rrbt","~$cljs.core/cons","~$clojure.core.rrb-vector.rrbt/Vector","~$clojure.core.rrb-vector.rrbt/peephole-optimize-root","~$clojure.core.rrb-vector.rrbt/rebalance-leaves","~$cljs.core/-conj!","~$clojure.core.rrb-vector.rrbt/bounded-grandchildren","~$cljs.core/first","~$clojure.core.rrb-vector.nodes/regular-ranges","~$clojure.core.rrb-vector.rrbt/RRBChunkedSeq","~$clojure.core.rrb-vector.nodes/index-of-nil","~$cljs.core/array-copy","~$cljs.core/vector-index-out-of-bounds","~$js/Error","~$clojure.core.rrb-vector.rrbt/IVecImpl","~$cljs.core/inc","~$cljs.core/-chunked-rest","~$clojure.core.rrb-vector.rrbt/max-extra-search-steps"]]],"~:cache-keys",["~#cmap",[["^1V","goog/dom/tagname.js"],["6025affb7181cd40418600864f58eed1ea80055d","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^[","~$goog.dom.HtmlElement"]]],["^1V","goog/math/math.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","~$goog.array","~$goog.asserts"]]],["^1V","goog/html/trustedtypes.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/labs/useragent/browser.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^1V","goog/html/safeurl.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^4S"]]],["^1V","goog/array/array.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P"]]],["^1V","clojure/core/rrb_vector/rrbt.cljs"],["aafb7677ec1e9f344fc834bbbdb91e8ba02af474","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^Z","^V","^W","^X","^Y"]]],["^1V","goog/debug/error.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","clojure/core/rrb_vector/trees.cljs"],["aafb7677ec1e9f344fc834bbbdb91e8ba02af474","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^Z","^W"]]],["^1V","clojure/core/rrb_vector/nodes.cljs"],["aafb7677ec1e9f344fc834bbbdb91e8ba02af474","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^Z"]]],["^1V","goog/dom/nodetype.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","clojure/core/rrb_vector/transients.cljs"],["aafb7677ec1e9f344fc834bbbdb91e8ba02af474","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^Z","^W","^X"]]],["^1V","goog/string/typedstring.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/object/object.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/dom/asserts.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P"]]],"~:SHADOW-TIMESTAMP",[1698164285000,1698164285000,1698163012000],["^1V","goog/math/long.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","~$goog.reflect"]]],["^1V","goog/html/trustedresourceurl.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","~$goog.html.trustedtypes","^4V","^4W","^4X","^4Y"]]],["^1V","goog/string/internal.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/functions/functions.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/html/safestyle.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","~$goog.html.SafeUrl","^4X","^4Y","^4S"]]],["^1V","goog/dom/safe.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","~$goog.html.SafeScript","~$goog.html.SafeStyle","^51","^4U","~$goog.html.uncheckedconversions","^4X","^4S"]]],["^1V","goog/structs/map.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1V","goog/html/safehtml.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","~$goog.dom.TagName","~$goog.dom.tags","^55","^56","~$goog.html.SafeStyleSheet","^51","^4U","^50","^4V","^4W","~$goog.labs.userAgent.browser","^4R","^4X","^4Y","^4S"]]],["^1V","goog/dom/tags.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4R"]]],["^1V","goog/asserts/asserts.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1V","goog/uri/uri.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1V","goog/i18n/bidi.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/fs/url.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/base.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",[]]],["^1V","goog/structs/structs.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4R"]]],["^1V","goog/string/string.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","~$goog.dom.safe","^57","^4X","^4S"]]],["^1V","clojure/core/rrb_vector/protocols.cljs"],["aafb7677ec1e9f344fc834bbbdb91e8ba02af474","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^Z"]]],["^1V","goog/reflect/reflect.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/labs/useragent/util.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4S"]]],["^1V","goog/string/stringbuffer.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","goog/iter/iter.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","^53","~$goog.math"]]],["^1V","goog/html/uncheckedconversions.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","^54","^55","^56","^5<","^51","^4U","^4X","^4S"]]],["^1V","goog/dom/htmlelement.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^["]]],["^1V","cljs/core.cljs"],["9f9729dbbf9b814c83dc189977b447d2ae92b6cd","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","~$goog.math.Long","~$goog.math.Integer","^5@","^4R","^4O","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1V","goog/html/safescript.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","^50","^4X","^4Y"]]],["^1V","goog/html/safestylesheet.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","^56","^4R","^4X","^4Y","^4S"]]],["^1V","goog/math/integer.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4["]]],["^1V","goog/uri/utils.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4O","^4P","^5@"]]],["^1V","goog/string/const.js"],["6025affb7181cd40418600864f58eed1ea80055d","^4J",["^ ","^4K",null,"^4L",["^J",[]],"^4M",["^[","^4P","^4Y"]]]]],"~:clj-info",["^ ","jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/tools.reader/1.3.3/tools.reader-1.3.3.jar!/clojure/tools/reader/default_data_readers.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/core.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/tools.reader/1.3.3/tools.reader-1.3.3.jar!/clojure/tools/reader/reader_types.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/util.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/compiler.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map/base64.clj",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/analyzer.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/data.json/1.0.0/data.json-1.0.0.jar!/clojure/data/json.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/tools.reader/1.3.3/tools.reader-1.3.3.jar!/clojure/tools/reader.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/env.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map/base64_vlq.clj",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/externs.clj",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/tagged_literals.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/js_deps.cljc",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/tools.reader/1.3.3/tools.reader-1.3.3.jar!/clojure/tools/reader/impl/inspect.clj",1698163010000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/core.rrb-vector/0.1.1/core.rrb-vector-0.1.1.jar!/clojure/core/rrb_vector/macros.clj",1698163014000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map.clj",1698163012000,"jar:file:/C:/Users/swolfc/.m2/repository/org/clojure/tools.reader/1.3.3/tools.reader-1.3.3.jar!/clojure/tools/reader/impl/errors.clj",1698163010000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1,"^8",5,"^9",1,"^:",33],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"~:shadow/protocol-prefixes",["^J",["clojure$core$rrb-vector$rrbt$IVecImpl$","clojure$core$rrb-vector$rrbt$AsRRBT$"]],"^F",["^ ","^G","^H"],"^I",["^J",["^K","^L","^M","^N","^O"]],"^P","^Q","^T",null,"^U",["^ ","^V","^V","^W","^W","^X","^X","^Y","^Y","^Z","^Z","^[","^["],"^10",["^J",["^11","^12"]],"~:shadow/js-access-global",["^J",["Error","Array"]],"^13",["^ ","^14","^Y","^15","^Y","^16","^Y","^17","^W","^18","^Y","^K","^X","^19","^W","^1:","^W","^1;","^W","^1<","^W","^1=","^W","^L","^X","^1>","^Y","^M","^X","^1?","^W","^1@","^V","^1A","^W","^1B","^V","^N","^X","^1C","^W","^1D","^W","^1E","^W","^1F","^W","^1G","^V","^1H","^W","^1I","^V","^1J","^Y","^1K","^W"],"~:defs",["^ ","~$shift-from-to",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",619,"^8",7,"^9",619,"^:",20,"~:arglists",["^1M",["~$quote",["^1M",[["~$node","~$from","~$to"]]]]]],"^P","^3Q","^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"~:method-params",["^1M",[["^6B","^6C","^6D"]]],"~:protocol-impl",null,"~:arglists-meta",["^1M",[null,null]],"^8",1,"~:variadic?",false,"^7",619,"^9",619,"~:max-fixed-arity",3,"~:fn-var",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6C","^6D"]]]]]],"~$peephole-optimization-config",["^ ","^P","^3S","^6","clojure/core/rrb_vector/rrbt.cljs","^7",898,"^8",1,"^9",898,"^:",34,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",898,"^8",6,"^9",898,"^:",34],"~:tag","~$cljs.core/Atom"],"~$peephole-optimization-count",["^ ","^P","^3H","^6","clojure/core/rrb_vector/rrbt.cljs","^7",899,"^8",1,"^9",899,"^:",33,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",899,"^8",6,"^9",899,"^:",33],"^6L","^6M"],"~$splice-rrbts-main",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1101,"^8",7,"^9",1101,"^:",24,"^6@",["^1M",["^6A",["^1M",[["~$v1","~$v2"]]]]]],"^P","^3I","^6","clojure/core/rrb_vector/rrbt.cljs","^:",24,"^6E",["^1M",[["^6P","^6Q"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",1101,"~:ret-tag",["^J",[null,"~$clj","~$any","^48"]],"^9",1101,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6P","^6Q"]]]]]],"~$slot-count",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",640,"^8",7,"^9",640,"^:",17,"^6@",["^1M",["^6A",["^1M",[["^6B","~$shift"]]]]]],"^P","^3Z","^6","clojure/core/rrb_vector/rrbt.cljs","^:",17,"^6E",["^1M",[["^6B","^6V"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",640,"^6R",["^J",["^6T","~$number"]],"^9",640,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V"]]]]]],"~$zippath",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",831,"^8",7,"^9",831,"^:",14,"^6@",["^1M",["^6A",["^1M",[["^6V","~$n1","~$cnt1","~$n2","~$cnt2","~$transferred-leaves"]]]]]],"^P","^3X","^6","clojure/core/rrb_vector/rrbt.cljs","^:",14,"^6E",["^1M",[["^6V","^6Y","^6Z","^6[","^70","^71"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",831,"^6R","~$array","^9",831,"^6I",6,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6V","^6Y","^6Z","^6[","^70","^71"]]]]]],"~$rrb-chunked-seq",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",117,"^8",7,"^9",117,"^:",22,"^6@",["^1M",["^6A",["^1M",[["~$vec","~$i","~$off"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","~$meta"]]]]],"~:top-fn",["^ ","^6H",false,"~:fixed-arity",5,"^6I",5,"^6E",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]],"^6@",["^1M",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]]],"^6G",["^1M",[null,null,null]]]],"^P","^3Y","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^77",["^ ","^6H",false,"^78",5,"^6I",5,"^6E",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]],"^6@",["^1M",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]]],"^6G",["^1M",[null,null,null]]],"^6E",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]],"^6F",null,"^78",5,"^6G",["^1M",[null,null,null]],"^8",1,"^6H",false,"~:methods",[["^ ","^78",3,"^6H",false,"^6L","^4?"],["^ ","^78",4,"^6H",false,"^6L","^4?"],["^ ","^78",5,"^6H",false,"^6L","^4?"]],"^7",117,"^9",117,"^6I",5,"^6J",true,"^6@",["^1M",[["^74","~$i","^75"],["^74","^6B","~$i","^75"],["^74","^6B","~$i","^75","^76"]]]],"~$-as-rrbt",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",26,"^8",4,"^9",26,"^:",12,"~:protocol","^30","~:doc",null,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"^7;","^30","^P","^46","^6","clojure/core/rrb_vector/rrbt.cljs","^:",12,"^6E",["^1M",[["~$v"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",25,"^6R","^6T","^9",26,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]],"^7<",null],"~$child-nodes",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",911,"^8",7,"^9",911,"^:",18,"^6@",["^1M",["^6A",["^1M",[["^6B"]]]]]],"^P","^41","^6","clojure/core/rrb_vector/rrbt.cljs","^:",18,"^6E",["^1M",[["^6B"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",911,"^6R","~$cljs.core/LazySeq","^9",911,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B"]]]]]],"~$AsRRBT",["^ ","^5",["^ ","~:protocol-symbol",true,"^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"^8",14,"^7",25,"~:protocol-info",["^ ","^79",["^ ","^7:",[["~$v"]]]],"^9",25,"~:sigs",["^ ","~:-as-rrbt",["^ ","^P","^7:","^6@",["^1M",[["~$v"]]],"^7<",null]],"~:jsdoc",["^1M",["@interface"]]],"^7@",true,"^P","^30","^6","clojure/core/rrb_vector/rrbt.cljs","^:",20,"^8",1,"^7",25,"^7A",["^ ","^79",["^ ","^7:",[["~$v"]]]],"~:info",null,"^9",25,"^6L","^6T","^7B",["^ ","^7C",["^ ","^P","^7:","^6@",["^1M",[["~$v"]]],"^7<",null]],"~:impls",["^J",["^2Y","^3@","^48"]],"^7D",["^1M",["@interface"]]],"~$fallback-to-slow-splice-count2",["^ ","^P","^2X","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1066,"^8",1,"^9",1066,"^:",36,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1066,"^8",6,"^9",1066,"^:",36],"^6L","^6M"],"~$bounded-grandchildren",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",925,"^8",7,"^9",925,"^:",28,"^6@",["^1M",["^6A",["^1M",[["~$children"]]]]]],"^P","^4<","^6","clojure/core/rrb_vector/rrbt.cljs","^:",28,"^6E",["^1M",[["^7I"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",925,"^6R","^7>","^9",925,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^7I"]]]]]],"~$max-vector-elements",["^ ","^P","^3D","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1023,"^8",1,"^9",1023,"^:",25,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1023,"^8",6,"^9",1023,"^:",25],"^6L","^6W"],"~$shift-too-large?",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1033,"^8",7,"^9",1033,"^:",23,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"^P","^3G","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^6E",["^1M",[["~$v"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",1033,"^6R","~$boolean","^9",1033,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"~$peephole-optimize-root",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",972,"^8",7,"^9",972,"^:",29,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"^P","^49","^6","clojure/core/rrb_vector/rrbt.cljs","^:",29,"^6E",["^1M",[["~$v"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",972,"^6R",["^J",[null,"^48"]],"^9",972,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"~$slice-left",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",178,"^8",7,"^9",178,"^:",17,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","~$start","~$end"]]]]]],"^P","^26","^6","clojure/core/rrb_vector/rrbt.cljs","^:",17,"^6E",["^1M",[["^6B","^6V","^7O","^7P"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",178,"^6R",["^J",["~$cljs.core/VectorNode","~$clj-nil"]],"^9",178,"^6I",4,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","^7O","^7P"]]]]]],"~$->Transient",["^ ","^6?",null,"^5",["^ ","~:protocols",["^J",["~$cljs.core/ICounted","~$cljs.core/ITransientCollection","~$cljs.core/ITransientVector","~$cljs.core/ITransientAssociative","^4D"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^8",10,"~:factory","~:positional","^7",1180,"^9",1180,"^6@",["^1M",["^6A",["^1M",[["~$cnt","^6V","~$root","~$tail","~$tidx"]]]]],"~:skip-protocol-flag",["^J",["^7U","^7V","^7W","^7X"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/Transient."],"^7T",["^J",["^7U","^7V","^7W","^7X","^4D"]],"^P","^3M","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^6E",["^1M",[["^7[","^6V","^80","^81","^82"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7Y","^7Z","^7",1180,"^6R","^2G","^9",1180,"^6I",5,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^7[","^6V","^80","^81","^82"]]]]],"^83",["^J",["^7U","^7V","^7W","^7X"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/Transient."],"~$fallback-to-slow-splice-count1",["^ ","^P","^3L","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1065,"^8",1,"^9",1065,"^:",36,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1065,"^8",6,"^9",1065,"^:",36],"^6L","^6M"],"~$RRBChunkedSeq",["^ ","~:num-fields",6,"^7T",["^J",["~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ASeq","~$cljs.core/ICollection","~$cljs.core/IChunkedNext","~$cljs.core/Object","~$cljs.core/IEmptyableCollection","~$cljs.core/ISeq","~$cljs.core/INext","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/IPrintWithWriter","~$cljs.core/IChunkedSeq","~$cljs.core/ISequential","~$cljs.core/IWithMeta","~$cljs.core/IReduce"]],"^P","^4?","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"~:type",true,"^8",10,"^7",33,"~:record",false,"^9",33,"^6L","~$function","^83",["^J",["^87","^88","^89","^8:","^8;","^8=","^8>","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]]],"~$count-vector-elements-beneath",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",950,"^8",7,"^9",950,"^:",36,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V"]]]]]],"^P","^2A","^6","clojure/core/rrb_vector/rrbt.cljs","^:",36,"^6E",["^1M",[["^6B","^6V"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",950,"^6R",["^J",["^6T","^6W"]],"^9",950,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V"]]]]]],"~$subtree-branch-count",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",649,"^8",7,"^9",649,"^:",27,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V"]]]]]],"^P","^42","^6","clojure/core/rrb_vector/rrbt.cljs","^:",27,"^6E",["^1M",[["^6B","^6V"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",649,"^6R","^6W","^9",649,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V"]]]]]],"~$poor-branching?",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1047,"^8",7,"^9",1047,"^:",22,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"^P","^2H","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^6E",["^1M",[["~$v"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",1047,"^6R","^7L","^9",1047,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"~$rrbt-concat-threshold",["^ ","^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",18,"^8",14,"^9",18,"^:",35,"~:const",true],"^P","^2J","^6","clojure/core/rrb_vector/rrbt.cljs","^:",35,"~:const-expr",["^ ","^R","^8N","~:val",33,"~:env",["^ ","~:context","~:expr"],"^1L",33,"^6L","^6W"],"^8",1,"^8N",true,"^7",18,"^9",18,"^6L","^6W"],"~$slice-right",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",125,"^8",7,"^9",125,"^:",18,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","^7P"]]]]]],"^P","^2D","^6","clojure/core/rrb_vector/rrbt.cljs","^:",18,"^6E",["^1M",[["^6B","^6V","^7P"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",125,"^6R","^7Q","^9",125,"^6I",3,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","^7P"]]]]]],"~$max-extra-search-steps",["^ ","^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",19,"^8",14,"^9",19,"^:",36,"^8N",true],"^P","^4G","^6","clojure/core/rrb_vector/rrbt.cljs","^:",36,"^8O",["^ ","^R","^8N","^8P",2,"^8Q",["^ ","^8R","^8S"],"^1L",2,"^6L","^6W"],"^8",1,"^8N",true,"^7",19,"^9",19,"^6L","^6W"],"~$child-seq",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",729,"^8",7,"^9",729,"^:",16,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","^7["]]]]]],"^P","^2B","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^6E",["^1M",[["^6B","^6V","^7["]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",729,"^6R","^6T","^9",729,"^6I",3,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6B","^6V","^7["]]]]]],"~$IVecImpl",["^ ","^5",["^ ","^7@",true,"^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^8",14,"^7",21,"^7A",["^ ","^79",["^ ","~$-tail-offset",[["~$v"]],"~$-array-for",[["~$v","~$i"]]]],"^9",21,"^7B",["^ ","~:-tail-offset",["^ ","^P","^8X","^6@",["^1M",[["~$v"]]],"^7<",null],"~:-array-for",["^ ","^P","^8Y","^6@",["^1M",[["~$v","~$i"]]],"^7<",null]],"^7D",["^1M",["@interface"]]],"^7@",true,"^P","^4D","^6","clojure/core/rrb_vector/rrbt.cljs","^:",22,"^8",1,"^7",21,"^7A",["^ ","^79",["^ ","^8X",[["~$v"]],"^8Y",[["~$v","~$i"]]]],"^7E",null,"^9",21,"^6L","^6T","^7B",["^ ","^8Z",["^ ","^P","^8X","^6@",["^1M",[["~$v"]]],"^7<",null],"^8[",["^ ","^P","^8Y","^6@",["^1M",[["~$v","~$i"]]],"^7<",null]],"^7F",["^J",["^2G","^48"]],"^7D",["^1M",["@interface"]]],"~$fallback-config",["^ ","^P","^2>","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1064,"^8",1,"^9",1064,"^:",21,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1064,"^8",6,"^9",1064,"^:",21],"^6L","^6M"],"~$last-non-nil-idx",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",942,"^8",7,"^9",942,"^:",23,"^6@",["^1M",["^6A",["^1M",[["~$arr"]]]]]],"^P","^2=","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^6E",["^1M",[["^92"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",942,"^6R","^6W","^9",942,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^92"]]]]]],"~$->RRBChunkedSeq",["^ ","^6?",null,"^5",["^ ","^7T",["^J",["^87","^88","^89","^8:","^8;","^8<","^8=","^8>","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^8",10,"^7Y","^7Z","^7",33,"^9",33,"^6@",["^1M",["^6A",["^1M",[["^74","^6B","~$i","^75","^76","~$__hash"]]]]],"^83",["^J",["^87","^88","^89","^8:","^8;","^8=","^8>","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq."],"^7T",["^J",["^87","^88","^89","^8:","^8;","^8<","^8=","^8>","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]],"^P","^2R","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^6E",["^1M",[["^74","^6B","~$i","^75","^76","^94"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7Y","^7Z","^7",33,"^6R","^4?","^9",33,"^6I",6,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^74","^6B","~$i","^75","^76","^94"]]]]],"^83",["^J",["^87","^88","^89","^8:","^8;","^8=","^8>","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/RRBChunkedSeq."],"^8X",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",22,"^8",4,"^9",22,"^:",16,"^7;","^4D","^7<",null,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]]],"^7;","^4D","^P","^2F","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^6E",["^1M",[["~$v"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",21,"^6R","^6T","^9",22,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v"]]]]],"^7<",null],"^8Y",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",23,"^8",4,"^9",23,"^:",14,"^7;","^4D","^7<",null,"^6@",["^1M",["^6A",["^1M",[["~$v","~$i"]]]]]],"^7;","^4D","^P","^43","^6","clojure/core/rrb_vector/rrbt.cljs","^:",14,"^6E",["^1M",[["~$v","~$i"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",21,"^6R","^6T","^9",23,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["~$v","~$i"]]]]],"^7<",null],"~$rebalance-leaves",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",670,"^8",7,"^9",670,"^:",23,"^6@",["^1M",["^6A",["^1M",[["^6Y","^6Z","^6[","^70","^71"]]]]]],"^P","^4:","^6","clojure/core/rrb_vector/rrbt.cljs","^:",23,"^6E",["^1M",[["^6Y","^6Z","^6[","^70","^71"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",670,"^6R","^72","^9",670,"^6I",5,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6Y","^6Z","^6[","^70","^71"]]]]]],"~$Vector",["^ ","^86",6,"^7T",["^J",["~$cljs.core/IIndexed","~$cljs.core/IVector","~$cljs.core/IReversible","~$cljs.core/IKVReduce","^87","^88","~$cljs.core/IFn","^8:","~$cljs.core/IEditableCollection","^8<","^30","^8=","^7U","~$clojure.core.rrb-vector.protocols/PSliceableVector","^8@","^8A","~$cljs.core/IStack","~$cljs.core/IMapEntry","^8B","~$cljs.core/IComparable","^8D","^8E","~$cljs.core/IAssociative","~$clojure.core.rrb-vector.protocols/PSpliceableVector","^4D","~$cljs.core/ILookup","^8F"]],"^P","^48","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^8G",true,"^8",10,"^7",271,"^8H",false,"^9",271,"^6L","^8I","^83",["^J",["^97","^98","^99","^9:","^87","^88","^9;","^8:","^9<","^8=","^7U","^8@","^8A","^9>","^9?","^8B","^9@","^8D","^8E","^9A","^9C","^8F"]]],"~$rebalance",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",746,"^8",7,"^9",746,"^:",16,"^6@",["^1M",["^6A",["^1M",[["^6V","^6Y","^6Z","^6[","^70","^71"]]]]]],"^P","^2N","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^6E",["^1M",[["^6V","^6Y","^6Z","^6[","^70","^71"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",746,"^6R","^72","^9",746,"^6I",6,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6V","^6Y","^6Z","^6[","^70","^71"]]]]]],"~$fallback-to-slow-splice-if-needed",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1068,"^8",7,"^9",1068,"^:",40,"^6@",["^1M",["^6A",["^1M",[["^6P","^6Q","~$splice-result"]]]]]],"^P","^2V","^6","clojure/core/rrb_vector/rrbt.cljs","^:",40,"^6E",["^1M",[["^6P","^6Q","^9F"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",1068,"^6R",["^J",[null,"^6S","^6T"]],"^9",1068,"^6I",3,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6P","^6Q","^9F"]]]]]],"~$leaf-seq",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",667,"^8",7,"^9",667,"^:",15,"^6@",["^1M",["^6A",["^1M",[["^92"]]]]]],"^P","^2;","^6","clojure/core/rrb_vector/rrbt.cljs","^:",15,"^6E",["^1M",[["^92"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",667,"^6R","^6T","^9",667,"^6I",1,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^92"]]]]]],"~$squash-nodes",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",867,"^8",7,"^9",867,"^:",19,"^6@",["^1M",["^6A",["^1M",[["^6V","^6Y","^6Z","^6[","^70"]]]]]],"^P","^2C","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^6E",["^1M",[["^6V","^6Y","^6Z","^6[","^70"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",867,"^6R","^72","^9",867,"^6I",5,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6V","^6Y","^6Z","^6[","^70"]]]]]],"~$Transient",["^ ","^86",5,"^7T",["^J",["^7U","^7V","^7W","^7X","^4D"]],"^P","^2G","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^8G",true,"^8",10,"^7",1180,"^8H",false,"^9",1180,"^6L","^8I","^83",["^J",["^7U","^7V","^7W","^7X"]]],"~$splice-rrbts",["^ ","^6?",null,"^5",["^ ","^6","clojure/core/rrb_vector/rrbt.cljs","^7",1175,"^8",7,"^9",1175,"^:",19,"^6@",["^1M",["^6A",["^1M",[["^6P","^6Q"]]]]]],"^P","^35","^6","clojure/core/rrb_vector/rrbt.cljs","^:",19,"^6E",["^1M",[["^6P","^6Q"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7",1175,"^6R",["^J",[null,"^6S","^6T"]],"^9",1175,"^6I",2,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^6P","^6Q"]]]]]],"~$->Vector",["^ ","^6?",null,"^5",["^ ","^7T",["^J",["^97","^98","^99","^9:","^87","^88","^9;","^8:","^9<","^8<","^30","^8=","^7U","^9=","^8@","^8A","^9>","^9?","^8B","^9@","^8D","^8E","^9A","^9B","^4D","^9C","^8F"]],"^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^8",10,"^7Y","^7Z","^7",271,"^9",271,"^6@",["^1M",["^6A",["^1M",[["^7[","^6V","^80","^81","^76","^94"]]]]],"^83",["^J",["^97","^98","^99","^9:","^87","^88","^9;","^8:","^9<","^8=","^7U","^8@","^8A","^9>","^9?","^8B","^9@","^8D","^8E","^9A","^9C","^8F"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/Vector."],"^7T",["^J",["^97","^98","^99","^9:","^87","^88","^9;","^8:","^9<","^8<","^30","^8=","^7U","^9=","^8@","^8A","^9>","^9?","^8B","^9@","^8D","^8E","^9A","^9B","^4D","^9C","^8F"]],"^P","^2?","^6","clojure/core/rrb_vector/rrbt.cljs","^:",16,"^6E",["^1M",[["^7[","^6V","^80","^81","^76","^94"]]],"^6F",null,"^6G",["^1M",[null,null]],"^8",1,"^6H",false,"^7Y","^7Z","^7",271,"^6R","^48","^9",271,"^6I",6,"^6J",true,"^6@",["^1M",["^6A",["^1M",[["^7[","^6V","^80","^81","^76","^94"]]]]],"^83",["^J",["^97","^98","^99","^9:","^87","^88","^9;","^8:","^9<","^8=","^7U","^8@","^8A","^9>","^9?","^8B","^9@","^8D","^8E","^9A","^9C","^8F"]],"^7<","Positional factory function for clojure.core.rrb-vector.rrbt/Vector."]],"^12",["^ ","^H","^H","^Z","^Z"],"~:cljs.analyzer/constants",["^ ","^10",["^J",["~$i","~:else","^6V","^94","^76","^74","~:debug-fn","^7[","^6B","~:mutable","^80","^81","^75","^82"]],"~:order",["^74","^6B","~$i","^75","^76","^94","^9O","^9M","^7[","^6V","^80","^81","^9N","^82"]],"^1R",["^ ","^11",["^J",[]],"^12",["^J",[]]],"^1S",["^ "],"^1T",["^[","^Z","^V","^W","^X","^Y"]],"^S","^Q","~:ns-specs",["^ "],"~:ns-spec-vars",["^J",[]],"~:compiler-options",["^4I",[["^9S","~:static-fns"],true,["^9S","~:shadow-tweaks"],null,["^9S","~:source-map-inline"],null,["^9S","~:elide-asserts"],false,["^9S","~:optimize-constants"],null,["^9S","^1Y"],null,["^9S","~:external-config"],null,["^9S","~:tooling-config"],null,["^9S","~:emit-constants"],null,["^9S","~:load-tests"],null,["^9S","~:form-size-threshold"],null,["^9S","~:data-readers"],null,["^9S","~:infer-externs"],"~:auto",["^9S","^1["],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^9S","~:fn-invoke-direct"],null,["^9S","~:source-map"],"/dev/null"]]]